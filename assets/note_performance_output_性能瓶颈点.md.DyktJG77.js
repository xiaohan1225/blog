import{_ as o,c as l,o as a,ae as c}from"./chunks/framework.CvsoPZUE.js";const i="/blog/assets/%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%82%B9%E6%A6%82%E8%A7%88.CC91vRoP.png",S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/performance/output/性能瓶颈点.md","filePath":"note/performance/output/性能瓶颈点.md"}'),r={name:"note/performance/output/性能瓶颈点.md"};function t(d,e,n,s,p,h){return a(),l("div",null,[...e[0]||(e[0]=[c('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>对于 Web 页面首屏优化，有时候明明感觉自己做了很多事情，比如精简了首屏内容，合并了请求资源，优化了项目打包配置，也对图片进行了压缩，但最后的首屏时间还是没有降低下来，这是为什么呢？</p><p>要解答这个问题，需要先了解页面加载的全流程。</p><h2 id="_1、页面加载全流程" tabindex="-1">1、页面加载全流程 <a class="header-anchor" href="#_1、页面加载全流程" aria-label="Permalink to &quot;1、页面加载全流程&quot;">​</a></h2><p>页面加载主要分为 3 个大的阶段：</p><ol><li>客户端发起请求阶段。</li><li>服务器处理请求阶段。</li><li>客户端页面渲染阶段。</li></ol><p><img src="'+i+'" alt="图片加载失败"></p><p>接下来针对这几个阶段进行详细介绍。</p><h2 id="_2、客户端请求阶段" tabindex="-1">2、客户端请求阶段 <a class="header-anchor" href="#_2、客户端请求阶段" aria-label="Permalink to &quot;2、客户端请求阶段&quot;">​</a></h2><p>客户端请求阶段可以分为下面 4 个子阶段：</p><ol><li>查询本地缓存。</li><li>DNS 解析。</li><li>TCP 连接。</li><li>HTTP 请求。</li></ol><h3 id="_2-1-查询本地缓存" tabindex="-1">2.1 查询本地缓存 <a class="header-anchor" href="#_2-1-查询本地缓存" aria-label="Permalink to &quot;2.1 查询本地缓存&quot;">​</a></h3><p>当用户在浏览器地址栏输入网址并按下 <code>enter</code> 键之后，浏览器会查询是否有可用的本地缓存，这个缓存分为两种：</p><ul><li><strong>强缓存</strong>：浏览器在加载资源时，会先根据请求头的 <code>expires</code> 或者 <code>cache-control</code> 判断是否命中强缓存，若命中，则直接从缓存中获取，不会发送请求到服务器。一般来说，对 <code>js</code>、<code>css</code> 和 <code>图片</code> 等资源会启用强缓存。</li><li><strong>协商缓存</strong>：浏览器会先发送请求到服务器，通过 <code>If-Modified-Since / Last-Modified</code>、<code>If-None-Match / ETag</code> 这两对 <code>请求/响应头</code>来判断资源是否命中协商缓存。 <ul><li>若命中，服务器会返回 <code>304</code> 状态码，代表资源 <code>Not Modified</code>，自然也不会返回资源内容，而浏览器接收到这个状态码之后，会从缓存中加载该资源。</li><li>若没命中缓存，会返回 <code>200</code> 状态码和新资源。</li></ul></li></ul><p>本地缓存是前端性能的瓶颈点之一，因为它可以大大提升静态资源的加载速度。</p><p>比如一个列表页的请求，<code>DNS 解析时间 50ms + TCP 三次握手、TLS 协商 400ms + 数据返回 200ms</code>，一个请求下来大约就 <code>650 ms</code>了，这个还是在强网（4G/5G/WIFI）情况下，如果在弱网（2G/3G）情况下，一个请求连接都需要 <code>1.5s</code>，而如果使用缓存的话，强缓存在<code>几毫秒</code>内就能完成，协商缓存的话，如果命中缓存，也只需要<code>几十毫秒</code>而已。</p><h3 id="_2-2-dns-解析阶段" tabindex="-1">2.2 DNS 解析阶段 <a class="header-anchor" href="#_2-2-dns-解析阶段" aria-label="Permalink to &quot;2.2 DNS 解析阶段&quot;">​</a></h3><p>DNS 解析之所以会成为前端性能瓶颈点，是因为每进行一次 DNS 查询，都要走一遍<code>手机 -&gt; 移动信号塔 -&gt; 认证 DNS 服务器</code>的过程，一般来说，DNS 解析要耗费 50ms 左右（强网环境），而如果使用浏览器本地 DNS 缓存，则耗时会在 1ms 以内。</p><p>我们可以对浏览器或者 <code>webview</code> 配置<code>DNS 预解析</code>的接口，加快这一速度。</p><h3 id="_2-3-tcp-连接阶段" tabindex="-1">2.3 TCP 连接阶段 <a class="header-anchor" href="#_2-3-tcp-连接阶段" aria-label="Permalink to &quot;2.3 TCP 连接阶段&quot;">​</a></h3><p>在 <code>OSI</code>七层网络通信参考模型中，这个主要是建立 TCP 连接主要是传输层做的工作，我们前端能做的事情十分有限，这里不多做介绍。</p><h3 id="_2-4-http-请求阶段" tabindex="-1">2.4 HTTP 请求阶段 <a class="header-anchor" href="#_2-4-http-请求阶段" aria-label="Permalink to &quot;2.4 HTTP 请求阶段&quot;">​</a></h3><p>这个阶段最大的瓶颈点来源于<code>请求阻塞</code>。<code>请求阻塞</code> 指的是浏览器为了保证访问速度，会对同域名的资源做连接数限制，一般是 6 个，超过了就要排队，后续请求需要等最先返回请求的连接结束之后，才能开始请求。</p><p>对于<code>请求阻塞</code>，我们可以采取一些优化手段：</p><ol><li><strong>域名规划</strong>。可以看看当前页面需要用到哪些域名，然后最关键的首屏需要用到哪些域名，规划下域名的发送顺序。</li><li><strong>域名散列</strong>。前面说同域名有连接数限制，那我们多搞几个域名就好了呀，比如我们图片资源的地址原来是 <code>image.example.com</code>,我们做成支持 <code>image0-5</code> 的域名地址，比如 <code>image0.example.com、image1.example.com、...image5.example.com</code>，每次请求时随机选一个域名进行请求，这样在同时有 6 个域名可以使用的情况下，我们网页的最大并发连接数就来到了 36 个，当然，这个域名个数不是越多越好，太分散的话会遇到多域名无法缓存静态资源的问题。</li><li><strong>使用HTTP2</strong>。<code>HTTP/2</code> 只需要一个 TCP 连接就能实现多路复用，解决了 <code>HTTP/1.1</code> 的队头阻塞问题，而且还有 <code>二进制分帧（Binary Framing）</code>、<code>头部压缩（HPACK）</code>、<code>服务器推送（Server Push）</code>等优化，其效率会比 <code>HTTP/1.1</code> 高出不少。</li></ol><h2 id="_3、服务端处理请求阶段" tabindex="-1">3、服务端处理请求阶段 <a class="header-anchor" href="#_3、服务端处理请求阶段" aria-label="Permalink to &quot;3、服务端处理请求阶段&quot;">​</a></h2><p>服务端处理请求阶段是指服务器收到请求后，从数据存储层取到数据，并经过一系列处理后返回给前端的过程。</p><p><strong>其瓶颈点如下</strong>：</p><ol><li>是否做了数据缓存。</li><li>是否做了 <code>Gzip</code> 压缩。</li><li>是否有重定向。</li></ol><h3 id="_3-1-数据缓存" tabindex="-1">3.1 数据缓存 <a class="header-anchor" href="#_3-1-数据缓存" aria-label="Permalink to &quot;3.1 数据缓存&quot;">​</a></h3><ol><li>对于后端来说，某一些特定的数据实时计算需要消耗大量的时间，比如排行榜数据，我们可以做 <code>T+1</code> 数据显示，也就是只显示前一天的数据，我们用定时任务把这些数据计算出来并缓存，然后取的时候不用实时计算速度就很快。</li><li>在前端层面，我们可以借助 <code>Service Worker</code> 的数据接口缓存能力，<code>Service Worker</code> 本质上是一个请求代理层，可以拦截和处理网络数据请求。</li><li>对于静态资源来说，我们可以使用 <code>CDN</code> 加速，它的基本思路是在各个地方放置缓存节点服务器，构造出一个智能虚拟网络，然后采用<code>就近访问</code>的原则，把用户的请求导向离用户最近的服务节点上，。</li></ol><h3 id="_3-2-gzip-压缩" tabindex="-1">3.2 Gzip 压缩 <a class="header-anchor" href="#_3-2-gzip-压缩" aria-label="Permalink to &quot;3.2 Gzip 压缩&quot;">​</a></h3><ul><li>对于静态资源来说，可以全局在 <code>nginx</code> 上全局开启 <code>gzip</code> 压缩。</li><li>对于接口数据来说，可以利用一些中间件或者自己手动实现 <code>gzip</code> 数据压缩，配合请求头 <code>accept-encoding</code> 和响应头去<code>content-encoding</code> 去实现。</li></ul><h3 id="_3-3-重定向" tabindex="-1">3.3 重定向 <a class="header-anchor" href="#_3-3-重定向" aria-label="Permalink to &quot;3.3 重定向&quot;">​</a></h3><ul><li>重定向指的是当网站资源地址发生变化后，程序会自动将请求导向另一个页面的过程。</li><li>重定向主要包括 <code>服务端 301、302 重定向</code>、<code>meta 标签实现的重定向</code>、<code>执行 JavaScript 通过 window.location 实现的重定向</code>。</li><li>重定向会重新走一遍 <code>DNS 查询 + TCP 连接 + TLS 协商 + 新的 HTTP 请求</code>过程，用户需要耗费更多的时间才能看到最终的页面内容，严重影响前端性能。</li></ul><h2 id="_4、客户端页面渲染阶段" tabindex="-1">4、客户端页面渲染阶段 <a class="header-anchor" href="#_4、客户端页面渲染阶段" aria-label="Permalink to &quot;4、客户端页面渲染阶段&quot;">​</a></h2><p>当客户端拿到服务器返回的 <code>HTML</code> 内容后，就会开始进入页面解析和渲染阶段，它主要包括以下流程：</p><ul><li><strong>构建 DOM 树</strong>：浏览器是无法理解和使用 HTML，所以需要把 HTML 转换为浏览器能够理解的结构，即 <code>DOM 树</code>。</li><li><strong>样式计算</strong>：将 CSS 的样式来源中（包括 link 标签、style 标记内书写的 CSS 以及元素的 style 属性中内嵌的 CSS），按照优先级整合成浏览器可以理解的结构，即 <code>styleSheets</code>，然后计算出 DOM 节点中每个元素的具体样式。</li><li><strong>布局阶段</strong>：计算出 DOM 树中可见元素的几何位置。</li><li><strong>分层</strong>：在渲染页面之前，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），比如 3D 变换、页面滚动、或者使用了 <code>z-index</code> 的元素。</li><li><strong>绘制</strong>：生成绘制指令，然后按照顺序组成一个待绘制列表。</li><li><strong>光栅化</strong>：将上一步骤的待绘制列表，提交给合成线程。合成线程会把图层划分为图块，并按照视口附近的图块来优先生成位图，光栅化就是把图块生成位图的过程。</li><li><strong>合成和显示</strong>：当所有的图块都被光栅化之后，合成线程会提交给浏览器进程来绘制图块，浏览器会把页面内容绘制到内存中，最后显示在页面上。</li></ul><p><strong>构建 DOM 树的瓶颈点</strong>：</p><ul><li><strong>HTML 标签是否语义化以及标签嵌套是否合理</strong>：当我们书写的 HTML 标签不符合语义化标准时，浏览器需要花更多的时间去解析各个 DOM 标签的含义，同时也会使 页面的 SEO 变差。比如 <strong>br 没写结束标签，表格嵌套不标准，标签层次结构复杂</strong>等，浏览器遇到这些情况时，需要进行语法纠错，导致页面总的解析和渲染时间变长。</li><li><strong>DOM 节点数量</strong>：这个很好理解，DOM 节点越多，构建 DOM 树的时间越长，所以我们可以使用<strong>懒加载或者虚拟列表</strong>等手段减少 DOM 节点个数。</li><li><strong>script 加载时机</strong>：<code>&lt;script&gt;</code> 标签中的 <code>JavaScript</code> 可以获取并修改 DOM，所以在解析到 <code>&lt;script&gt;</code> 标签后，<code>DOM</code> 树的构建会被暂停，所以能延迟加载，就使用 <code>defer</code> 和 <code>async</code> 等属性异步加载，不阻塞 DOM 的解析。</li></ul><p><strong>CSS 样式计算中的瓶颈点</strong>：</p><ul><li><strong>CSS 加载性能</strong>：是否做了公共样式抽离？是否删除了多余的 CSS？是否合理利用了内嵌CSS？</li><li><strong>CSS 选择器性能</strong>：是否滥用了通配符选择器？选择层级是否嵌套过深？</li><li><strong>CSS 属性性能</strong>：是否使用了复杂或者不必要的 CSS 属性？是否滥用了 <code>!important</code>?</li><li><strong>CSS 动画性能</strong>：是否使用了 <code>transform</code>、<code>will-change</code> 、<code>requestAnimationFrame()</code>等优化了动画？</li><li><strong>CSS 渲染性能</strong>：是否使用了 <code>class</code> 合并 <code>DOM</code> 的修改？是否让 <code>DOM</code> 元素脱离文档流？</li></ul><p>关于 <code>CSS</code> 的性能优化，有兴趣详细了解的话可查看我之前写的 <a href="https://mp.weixin.qq.com/s/0Gl2sGa2Ev44tyrSYjjyFg" target="_blank" rel="noreferrer">前端性能优化之CSS篇</a>。</p><p><strong>布局中的瓶颈点</strong>：</p><ul><li>如果在页面渲染过程运行时修改了一个元素的属性，这时候就会触发浏览器的<code>重排</code>或者<code>重绘</code>，增加布局时间。</li><li>每次布局都需要计算整个 DOM 的几何位置，如果 DOM 节点很多，那么会花费很长的时间。</li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>页面加载主要分为 3 个大的阶段，包括客户端请求、服务端处理请求和客户端渲染阶段：</p><ul><li>客户端请求的瓶颈点：查询本地缓存、DNS 解析、TCP 连接和 HTTP 请求阶段。</li><li>服务端处理请求阶段的瓶颈点：数据缓存、Gzip 压缩和重定向。</li><li>客户端页面渲染阶段的瓶颈点：构建 DOM 树阶段、CSS 样式计算阶段和布局阶段。</li></ul><h2 id="往期回顾" tabindex="-1">往期回顾 <a class="header-anchor" href="#往期回顾" aria-label="Permalink to &quot;往期回顾&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s/W8fkvEjbHlFpIg3_RMXGpA" target="_blank" rel="noreferrer">前端性能优化之Webpack篇</a></li><li><a href="https://mp.weixin.qq.com/s/0Gl2sGa2Ev44tyrSYjjyFg" target="_blank" rel="noreferrer">前端性能优化之CSS篇</a></li><li><a href="https://mp.weixin.qq.com/s/eIKLx_kegGzrB00KXeKYLQ" target="_blank" rel="noreferrer">前端遇到页面卡顿问题，如何排查和解决？</a></li></ul>',50)])])}const m=o(r,[["render",t]]);export{S as __pageData,m as default};
