import{_ as l,o as i,c as t,ae as a}from"./chunks/framework.ByOFQPzk.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/performance/18.性能演进：RN、Flutter、小程序和 Enhance Hybrid.md","filePath":"note/performance/18.性能演进：RN、Flutter、小程序和 Enhance Hybrid.md"}'),r={name:"note/performance/18.性能演进：RN、Flutter、小程序和 Enhance Hybrid.md"};function p(n,e,u,o,d,s){return i(),t("div",null,[...e[0]||(e[0]=[a('<h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>多端场景下的性能优化方案————RN、Flutter 和小程序。</p><ul><li>RN 即 ReactNative，是 Facebook 开发的开源移动应用架构，它可以让开发者基于 JavaScript 和 React.js 开发跨平台移动应用。</li><li>Flutter 是一个由 Google 开发的开源移动方案，与 RN 类似，主要为 Android、IOS 系统开发应用。它的技术架构屏蔽了平台的概念，把多端优势在更底层解决掉了，同时渲染性能更好。除此之外，Flutter 最大的优势在于提升了开发效率。我之前在实际项目中实验过，相对于 安卓和 ios 两端开发，可以降低 40% 的开发成本。</li><li>小程序则是一种不需要下载安装，即可在微信平台上使用的程序，它主要为开发者在微信平台上提供服务。</li></ul><h2 id="rn-原理及其性能优化" tabindex="-1">RN 原理及其性能优化 <a class="header-anchor" href="#rn-原理及其性能优化" aria-label="Permalink to &quot;RN 原理及其性能优化&quot;">​</a></h2><p>一般在移动端开发中，我们会使用原生应用或者 H5。</p><ul><li>如果使用原生开发的话，由于客户端发版和版本审核，迭代周期会比较长，而使用H5的话，它的性能体验又比较差，不如原生应用流畅。</li></ul><p>RN 会把应用的 JS 代码编译成一个 buddle.js，它整体框架的目的就是解释运行这个 js 文件，在这个框架下，上线周期和 Hybrid 类似，但因为框架层负责跨平台的渲染，渲染效率比 Hybrid 好得多。</p><p>2016 年初我使用 RN 改造个人中心页面，当时遇到了两个难题：</p><ul><li>Listview 无限下拉列表初始渲染慢，滚动过程中卡顿体验差的问题。</li><li>用户在拍照时，遇到的卡死的问题，根源是调用拍照控件时出现卡顿。</li></ul><p>最初是通过官方提供的 Flatlist 来解决。由于 Flatlist 追求比较一致的滑动体验，使用空白的 view 组件进行占位，如果你滑动比较快，会来不及渲染就会出现白屏。</p><p>后来我做了基础调研后，在 Native 侧封装了一个原生的 Listview，通过RN层来调用解决了这个问题。</p><p>调起照片控件时出现卡顿，后来定位发现，原来是 JS 调用 Native 照片预览时，出现了延迟。为什么会这样呢？</p><p>目前的RN框架，是基于大量JSON序列化和反序列化来进行通信的，它的大致逻辑包括以下两点：</p><ul><li>从 JS 到 Native 通信，即当 JS 调用 RN 控件时，JS 会把它需要调用的 NativeModule 函数和 NativeModule 对应的名称参数用 JSON 序列化后，传递给 Native，Native 接着会提取并调用对应的 NativeModule 方法。</li><li>从 Native 返回向 JS 通信，Native 先通过 CreateInstance 将数据处理成 JSON，再传递给 JS，JS 完成调用 JSModule，以实现 Native 调用 JS 组件的能力。</li></ul><p>在通讯过程中，如果出现调用延迟，会导致操作后没反应的情况，这就需要通过周期性类似ping 的方式来检测是否出现延迟。具体来说，在调用ping指令后对时间进行记录，如果时间超过某个阈值，则认为出现延迟了，阻塞延迟后需要等待该进程的结束，而非持续排队调用。解决过程中还需要注意两点：</p><ul><li>原有 Hybrid 工程迁移到 RN 过程中，会发现很多新旧功能兼容问题，此时我们可以重新根据 RN 下的体验去设计页面功能，而不是盲目做功能拷贝。</li><li>提前做好 RN 基础建设，打包编译和热更新流程，尽量和 Hybrid 下的基建体系保持统一。</li></ul><h2 id="flutter-及其性能优化" tabindex="-1">Flutter 及其性能优化 <a class="header-anchor" href="#flutter-及其性能优化" aria-label="Permalink to &quot;Flutter 及其性能优化&quot;">​</a></h2><p>当我们使用RN开发移动端应用是，以为要适配 Android 和 IOS 两端，会导致代码复杂度特别高的情况，而使用 Flutter 可以避免这一情况。因为 Flutter 自带的渲染引擎和视图，可以帮我们完成组件层的闭环渲染，避免了像 RN 一样还要在组件层和渲染层分别实现。</p><p>使用 Flutter，前端的性能问题一般会出现在哪里呢？我们该如何进行优化？</p><ul><li>用户滑动操作不流畅，因为丢帧导致的卡顿</li><li>操作流程被中断，陷入等待，也就是页面资源加载时间过长</li></ul><p>选定页面滑动的流畅度（FPS）和页面加载耗时，作为性能指标。</p><p>FPS 指标的采集一般借助 mChoreographer 和 CFRunLoop 实现。但由于这两种方法都是在主线程上进行的，而Flutter 的绘制是在 UI TaskRunner 中完成，在 GPU TaskRunner 中渲染，所以以往的 FPS 检测方法并不适用于 Flutter。Flutter 官方也提供了 performanceOfline，缺点是无法提供在线监控的性能指标，最后参考业界采用 handleBeginFrame 和 handleDrawFrame 之间的时间间隔来计算帧率，前者用来启动一个新帧，后者用于帧的绘制。</p><p>具体做法：</p><ul><li>在使用 App 进行交互操作，开始时计时，1s内打印下开始时间 startTime，然后在 handleBeginTime 方法回调时进行记录，再在 handleDrawFrame 方法回调时进行记录，结束计时打印下 endTime，将 endTime - startTime 存储数组 PerfArr 中。</li><li>计时达到 1s 后，计算刷新次数 PerfArr.length，PerfArr 中超过 16.6ms 的认为丢帧，如果连续 5 帧超过 50ms 则认为卡顿，单帧超过 250ms 则认为严重卡顿。</li><li>根据卡顿进行预警即可</li></ul><h2 id="小程序及其性能治理方案" tabindex="-1">小程序及其性能治理方案 <a class="header-anchor" href="#小程序及其性能治理方案" aria-label="Permalink to &quot;小程序及其性能治理方案&quot;">​</a></h2><p>H5 会出现白屏和页面切换不流畅的问题，与此同时，我们也希望 App 可以随时更新而不需要上架审核。</p><p>小程序分为微信、支付宝、百度、头条等多种，这里主要介绍下微信小程序：</p><ul><li>微信小程序主要通过设计一套自己的 web + 离线包方案来实现，这样既能保证跨平台实时更新，还能保证性能体验。</li><li>小程序还能禁掉一些不合适的标签（如跳URL的A标签）和 API（如动态执行脚本的API），减少安全问题，此外它还能避免JS操作DOM，从而提升渲染性能。</li></ul><p>一般小程序的前端性能，我们主要关注首屏时间。</p><p>2016年我在做微信支付项目时，收到用户反馈，主程序加载慢。</p><ul><li>先做了首屏时间的采集，通过 setData 结束时间 - 路由开始时间获取到，发现首屏时间一度超过 5s。</li></ul><p>小程序是放在微信支付的九宫格中的，大概有千万级的流量，公司很多业务都想使用这个流量，于是我们在小程序首页就增加了一个入口逻辑，随着业务增加，首页的代码量也越来越大。</p><p>小程序架构：</p><ul><li>小程序启动时，也分为逻辑层的启动和视图层的启动，逻辑层的启动主要是加载 JS 代码，视图层则是启动 webview 对页面进行加载和渲染。</li></ul><p>经过分析，我们发现问题出在首页包过大上，它导致逻辑层加载过慢，首屏时间超标。</p><p>解决：</p><ul><li>先整理和清理包资源，比如把小的 icon 都统一从网络加载的方案</li><li>无用资源及时清除</li><li>采用分包加载的机制减少首屏时间</li></ul><p>分包加载就是根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放在子包里，按需加载。</p><ul><li>启动时只加载主包，使用时再按需下载子包，这样主包从 1.2M 降低到 0.5M，首屏时间达到微信小程序下首屏时间标准，即3s。</li></ul><p>注意：</p><ul><li>要在项目方案设计时，就做好代码和资源目录文件的划分，主要功能所依赖的资源，要放在主包里，子包的拆分不需要太细。如果用户点击到子包相关的页面感觉到卡顿，可以做一些预加载处理。</li></ul>',41)])])}const c=l(r,[["render",p]]);export{_ as __pageData,c as default};
