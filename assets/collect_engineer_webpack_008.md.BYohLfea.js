import{_ as a,c as i,o as e,ae as l}from"./chunks/framework.BFe6FF_l.js";const c=JSON.parse('{"title":"008 webpack的loader原理","description":"","frontmatter":{"title":"008 webpack的loader原理","date":"2022-03-05T00:00:00.000Z","categories":["Webpack"],"tags":["Webpack"],"sidebar":"auto"},"headers":[],"relativePath":"collect/engineer/webpack/008.md","filePath":"collect/engineer/webpack/008.md"}'),n={name:"collect/engineer/webpack/008.md"};function t(p,s,d,h,o,r){return e(),i("div",null,[...s[0]||(s[0]=[l(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><code>loader</code>是webpack构建流程中非常重要的一部分，webpack的特点是一个<code>JavaScript打包工具</code>，默认只能处理<code>js</code>文件，而对于html、css、图片等非js模块是无法处理的，这时候就要loader了。</p><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>loader是一个<code>转换器</code>，在webpack中一般是根据test匹配到对应的模块，然后调用配置的loader做资源的转换和处理，最终loader给到webpack的一定是一段<code>js脚本</code>。</p><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><p>loader有四种：</p><ol><li>前置loader（pre loader）</li><li>普通loader（normal loader）</li><li>后置loader（post loader）</li><li>行内loader（inline loader）</li></ol><p>可通过每条<code>rule</code>中的<code>enforce</code>属性配置前置、普通和后置loader，默认为普通loader。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>module: {</span></span>
<span class="line"><span>  rules: [</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      test: /\\.js$/,</span></span>
<span class="line"><span>      use: [&#39;pre-loader&#39;],</span></span>
<span class="line"><span>      enforce: &#39;pre&#39;,</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      test: /\\.js$/,</span></span>
<span class="line"><span>      use: [&#39;normal-loader&#39;],</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span>      test: /\\.js$/,</span></span>
<span class="line"><span>      use: [&#39;post-loader&#39;],</span></span>
<span class="line"><span>      enforce: &#39;post&#39;,</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>  ]</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>行内loader则是通过require或import的方式引入进行使用,比如<code>!inline-loader./index.css</code>，则表示用行内loader<code>inline-loader</code>处理index.css文件。同时用行内loader可以使用一些前缀：</p><table tabindex="0"><thead><tr><th style="text-align:center;">前缀</th><th style="text-align:center;">含义</th></tr></thead><tbody><tr><td style="text-align:center;">-!</td><td style="text-align:center;">不要前置和普通loader</td></tr><tr><td style="text-align:center;">!</td><td style="text-align:center;">不要普通loader</td></tr><tr><td style="text-align:center;">!!</td><td style="text-align:center;">不要前、后置和普通loader，只要行内loader</td></tr></tbody></table><h2 id="输入输出" tabindex="-1">输入输出 <a class="header-anchor" href="#输入输出" aria-label="Permalink to &quot;输入输出&quot;">​</a></h2><p><code>loader</code>是一个函数，输入为string/buffer，其输入来源为源文件或上个loader的返回值，其输出为string/buffer，最后的loader的返回值是一段<code>js脚本</code>，并给到webpack。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;//loader&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.raw </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><p>将raw设置为true可接收到源文件的二进制buffer。</p><h2 id="执行流程" tabindex="-1">执行流程 <a class="header-anchor" href="#执行流程" aria-label="Permalink to &quot;执行流程&quot;">​</a></h2><p>loader的执行分为两个阶段：<code>pitch</code>和<code>normal</code>。</p><p>比如处理less文件，做了如下配置：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// webpack.config.js</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      test: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">less$/&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      use: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;style-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;css-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;less-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最终的执行顺序为：</p><ol><li><code>style-loader pitch</code></li><li><code>css-loader pitch</code></li><li><code>less-loader pitch</code></li><li>读取源文件</li><li><code>less-loader normal</code></li><li><code>css-loader normal</code></li><li><code>style-loader normal</code></li></ol><p><code>pitch</code>阶段会先于<code>normal</code>阶段执行，如果<code>pitch</code>方法返回了内容，则会跳过<code>右侧loader的normal和pitch阶段</code>。</p><p>比如上述的<code>css-loader</code>的<code>pitch</code>方法如果返回了内容，则执行顺序变为：</p><ol><li><code>style-loader pitch</code></li><li><code>css-loader pitch</code></li><li><code>style-loader normal</code></li></ol><p><code>pitch</code>方法定义如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> content </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;normal&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// remainingRequest：当前loader之后的loader的request字符串</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// precedingRequest：当前loader之前的loader的request字符串</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// data：loader链中的共享数据，在normal中可通过this.data获取</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pitch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">remainingRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">precedingRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p><code>loader</code>的叠加顺序：post(后置)+inline(内联)+normal(正常)+pre(前置)，其执行顺序为</p><ol><li><code>post loader pitch</code></li><li><code>inline loader pitch</code></li><li><code>normal loader pitch</code></li><li><code>pre loader pitch</code></li><li>读取源文件</li><li><code>pre loader normal</code></li><li><code>normal loader normal</code></li><li><code>inline loader normal</code></li><li><code>post loader normal</code></li></ol><h2 id="loader-runner" tabindex="-1">loader-runner <a class="header-anchor" href="#loader-runner" aria-label="Permalink to &quot;loader-runner&quot;">​</a></h2><p>webpack中<code>loader</code>是通过<a href="https://github.com/webpack/loader-runner" target="_blank" rel="noreferrer">loader-runner</a>来进行调用的。它在调用<code>loader</code>时提供了一些可供<code>loader</code>使用的上下文信息(loaderContext)：</p><ol><li><code>this.getOptions</code>：获取配置文件传给该loader的options</li><li><code>this.callback</code>：调用此方法会将该<code>loader</code>的处理结果往下传</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  err: Error </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  content: string </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Buffer,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 返回本次转换中生成的sourcemap 比如babel-loader转化了js文件，需要返回sourcemap给webpack，要不然webpack生成sourcemap时定位不到最开始的源文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  sourceMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SourceMap,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 本次转换中生成的额外信息，可自定义。例如本次转换为源文件生成了AST，则可将该AST传给后面的loader，以免需要AST的loader去重复生成而降低性能。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  meta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> any</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><ol start="3"><li><code>this.async</code>：调用此函数返回<code>this.callback</code>，用来实现<code>异步loader</code>。</li><li><code>this.request</code>：request字符串</li><li><code>this.loaders</code>：loader的调用链数组</li><li><code>this.addDependency</code>：添加一个文件作为<code>loader</code>的依赖，如开启缓存，该文件发生变化会导致缓存失效，从而重新调用<code>loader</code></li><li><code>this.addContextDependency</code>：添加一个目录作为<code>loader</code>的依赖</li><li><code>this.sourceMap</code>：可调用此方法查看是否要求生成<code>source map</code></li><li><code>emitFile</code>：输出一个文件</li></ol>`,33)])])}const E=a(n,[["render",t]]);export{c as __pageData,E as default};
