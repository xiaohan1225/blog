import{_ as i,c as l,o,ae as t}from"./chunks/framework.BezmCoJM.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/interview/interview.md","filePath":"collect/interview/interview.md"}'),c={name:"collect/interview/interview.md"};function d(a,e,r,s,p,n){return o(),l("div",null,[...e[0]||(e[0]=[t('<h2 id="seo优化" tabindex="-1">SEO优化 <a class="header-anchor" href="#seo优化" aria-label="Permalink to &quot;SEO优化&quot;">​</a></h2><ol><li>tdk：title，description，keywords</li><li>SSR</li></ol><ul><li>vue同构渲染</li><li>客户端注入 <ul><li>页面中的DOM元素和虚拟节点建议联系</li><li>添加事件绑定 步骤：</li></ul></li></ul><ol><li>客户端/服务端两个入口，vuex/vue-router不能单例</li><li>webpack打包配置，客户端和服务端分别打包</li><li>数据预拉取：serverPrefetch，服务端数据同步到客户端 INITIAL_STATE</li><li>jsdom模拟客户端环境</li><li>客户端激活<code>data-server-rendered=&quot;true&quot;</code></li></ol><p>注意的坑：</p><ol><li>浏览器会在 <code>&lt;table&gt;</code> 内部自动注入 <code>&lt;tbody&gt;</code>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <code>&lt;tbody&gt;</code>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML</li><li>服务端渲染时，如果客户端有接口缓存，会导致无法渲染</li></ol><p>优化性能：</p><ol><li>增加缓存，第一次走客户端渲染，之后走缓存，最大程度加快速度，缓存时间 30min</li></ol><p>日志统计+报错监控：</p><ol><li>统计SSR成功率，收集报错，分析原因</li><li>服务器性能监控，并发高时是否需要扩容</li></ol><h2 id="webpack迁移到vite" tabindex="-1">webpack迁移到vite <a class="header-anchor" href="#webpack迁移到vite" aria-label="Permalink to &quot;webpack迁移到vite&quot;">​</a></h2><p>核心目的：</p><ol><li>提升开发体验，热更新更快</li></ol><p>vite特点：</p><ol><li>no-bundle 热更新快</li><li>不支持 commonjs</li></ol><p>改造过程：</p><ol><li>增加依赖</li></ol><ul><li><code>@originjs/vite-plugin-commonjs</code>: 将commonjs转为esm</li><li><code>@originjs/vite-plugin-require-context</code>: 把require转化成import</li><li><code>vite</code>: vite核心包</li><li><code>vite-plugin-env-compatible</code>: 环境变量兼容，比如<code>process.env.xx</code></li><li><code>vite-plugin-svg-icons</code>: 兼容svg</li><li><code>vite-plugin-vue2</code>: 兼容vue</li></ul><ol start="2"><li>创建<code>vite.config.ts</code></li></ol><ul><li><code>server</code>：配置代理</li><li><code>resolve.alias</code>：配置别名</li><li><code>resolve.extensions</code>: 配置文件后缀</li></ul><ol start="3"><li>改造入口，<code>index.html</code>放在根目录下，里面通过<code>script[type=&quot;module&quot;]</code>引入<code>main.js</code></li><li>css默认支持<code>sass</code>,不支持<code>node-sass</code>，需要更换（项目中一些node-sass语法需要更换，比如/deep/换成::v-deep）</li></ol><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><ol><li>单例模式</li><li>发布订阅模式/观察者模式</li><li>代理模式</li><li>策略模式</li><li>享元模式 共享内存，减少开销。</li></ol><p>java里的String常量池，Integer的缓存池 等都是享元模式的体现。系统创建多个常用的对象，他们共用同一份内存，节省内存空间。</p><p>反向，有些因为公用内存引发bug，比如初始化时用了同一份对象</p><p>js应用：</p><ol><li><p>事件委托</p></li><li><p>图片或资源加载，复用同一个DOM，避免重复加载资源</p></li><li><p>虚拟列表</p></li><li><p>CSS类共享，在样式定义在css类上，通过增加类名和减少类名来控制样式</p></li><li><p>工厂模式</p></li><li><p>模板方法模式 它定义了一个算法的框架，并允许子类在不改变算法结构的情况下重写算法的某些步骤。模板方法模式通过将算法的通用部分放在父类中，而将可变部分留给子类实现，从而实现了代码复用和扩展性。</p></li></ol><p>父类定义成抽象类，子类去实现。 vue的声明式框架，以及vue中的extends有点这种味道，但更好的写法是vue3 composition api，方便抽离和复用 7. 装饰者模式 8. 适配器模式</p>',28)])])}const m=i(c,[["render",d]]);export{v as __pageData,m as default};
