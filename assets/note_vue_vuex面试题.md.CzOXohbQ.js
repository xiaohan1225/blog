import{_ as i,c as a,o as t,ae as n}from"./chunks/framework.BFe6FF_l.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/vue/vuex面试题.md","filePath":"note/vue/vuex面试题.md"}'),e={name:"note/vue/vuex面试题.md"};function l(h,s,p,o,r,k){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h2 id="_1、vuex-是什么-什么情况下应该使用-vuex" tabindex="-1">1、Vuex 是什么？什么情况下应该使用 Vuex？ <a class="header-anchor" href="#_1、vuex-是什么-什么情况下应该使用-vuex" aria-label="Permalink to &quot;1、Vuex 是什么？什么情况下应该使用 Vuex？&quot;">​</a></h2><p>Vuex 是专门为 Vue.js 应用提供状态管理模式的一个库，也是 Vue.js 官方推荐的状态管理方案，它将所有数据集中存储到一个全局 <code>store</code> 对象中，并制定了一定的规则，保证状态以预期的方式发生变化。</p><p>它的核心概念有：</p><ul><li><strong>state</strong>：存储状态，并提供响应式能力。</li><li><strong>getter</strong>: 从 state 中派生出一些状态，相当于 Vue.js 中的计算属性 computed。</li><li><strong>mutation</strong>: 通过提交 mutation，是 Vuex 中修改 state 的推荐方式。</li><li><strong>action</strong>：可以包括异步操作，异步操作处理完后，通过提交 mutation 修改状态。</li><li><strong>module</strong>: 模块化，可以将 store 分割成一个个小模块，每个模块拥有自己的 state、getter、mutation、action，甚至是嵌套子模块。</li></ul><p>在构建<strong>中大型单页应用</strong>时，各组件和模块的状态流转逻辑会相当复杂，这时候就可以使用 <code>Vuex</code> 进行全局状态管理，并且里面用<code>严格的 mutation</code> 保证了状态的预期流转，使得项目的数据流变得清晰，提高了项目可维护性。</p><h2 id="_2、如何解决页面刷新后-vuex-的数据丢失问题" tabindex="-1">2、如何解决页面刷新后 Vuex 的数据丢失问题？ <a class="header-anchor" href="#_2、如何解决页面刷新后-vuex-的数据丢失问题" aria-label="Permalink to &quot;2、如何解决页面刷新后 Vuex 的数据丢失问题？&quot;">​</a></h2><p><strong>数据丢失原因</strong>：Vuex 中的状态 state 是存储在内存中的，刷新页面会导致内存清空，所以数据丢失。</p><p><strong>解决方案：</strong></p><h3 id="_2-1-第一步-使用持久化存储保存数据" tabindex="-1">2.1 第一步：使用持久化存储保存数据 <a class="header-anchor" href="#_2-1-第一步-使用持久化存储保存数据" aria-label="Permalink to &quot;2.1 第一步：使用持久化存储保存数据&quot;">​</a></h3><p>将 Vuex 的数据在合适时机（比如监听 window 的<code>beforeunload</code> 事件）保存到浏览器的本地存储（<code>localStorage</code> 或 <code>sessionStorage</code>），也可以直接采用 <code>vuex-persistedstate</code> 持久化插件（默认会存储到 localStorage 中，可通过配置修改）进行本地存储。</p><h3 id="_2-2-第二步-初始化应用-替换状态" tabindex="-1">2.2 第二步：初始化应用，替换状态 <a class="header-anchor" href="#_2-2-第二步-初始化应用-替换状态" aria-label="Permalink to &quot;2.2 第二步：初始化应用，替换状态&quot;">​</a></h3><p>应用初始化加载时，获取存储中的状态进行替换。Vuex 给我们提供了一个 <code>replaceState(state: Object)</code> API，可以很方便进行状态替换。</p><h3 id="_2-3-第三步-检查数据-发起请求" tabindex="-1">2.3 第三步：检查数据，发起请求 <a class="header-anchor" href="#_2-3-第三步-检查数据-发起请求" aria-label="Permalink to &quot;2.3 第三步：检查数据，发起请求&quot;">​</a></h3><p>在状态替换后，还需要检查 Vuex 中的数据是否存在，如果不存在则可以在 <code>action</code> 中发送接口请求拿到数据，通过提交 <code>mutation</code> 修改状态把数据存储到 <code>store</code> 中。</p><h3 id="_2-4-第四步-状态同步" tabindex="-1">2.4 第四步：状态同步 <a class="header-anchor" href="#_2-4-第四步-状态同步" aria-label="Permalink to &quot;2.4 第四步：状态同步&quot;">​</a></h3><p>状态变化后将状态同步到浏览器存储中，保证本地存储中状态的实时性。</p><blockquote><p>不过要注意的是，如果把数据持久化到 localStorage 或者 sessionStorage 中，会有一定的安全风险：</p><ol><li>数据直接全部暴露在 storage 可通过控制台的 <code>Application</code> 选项卡进行查看，数据容易泄漏。持久化的数据毕竟没有内存中的数据安全。</li><li>用户可以直接在控制台 <code>Application</code> 中直接修改数据，从而可能绕过某些权限校验，看到一些预期外的界面和交互。</li></ol></blockquote><h2 id="_3、mutation-和-action-的区别有哪些" tabindex="-1">3、mutation 和 action 的区别有哪些？ <a class="header-anchor" href="#_3、mutation-和-action-的区别有哪些" aria-label="Permalink to &quot;3、mutation 和 action 的区别有哪些？&quot;">​</a></h2><ul><li><strong>作用不同</strong>：action 是用来处理异步逻辑或者业务逻辑，而 mutation 是用来修改状态的。</li><li><strong>使用限制</strong>：action 中可以调用 mutation 或者其他 action，而 mutation 中则只能修改 state。</li><li><strong>返回值不同</strong>：<code>dispatch</code> 时会将 action 包装成 promise，而 mutation 则没进行包装。</li><li><strong>严格模式下的差异</strong>：在 Vuex 开启严格模式 <code>strict: true</code> 后，任何非 mutation 函数修改的状态，将会抛出错误。</li></ul><h3 id="扩展-vuex-严格模式是如何监听非-mutation-函数修改状态的" tabindex="-1">扩展：vuex 严格模式是如何监听非 mutation 函数修改状态的？ <a class="header-anchor" href="#扩展-vuex-严格模式是如何监听非-mutation-函数修改状态的" aria-label="Permalink to &quot;扩展：vuex 严格模式是如何监听非 mutation 函数修改状态的？&quot;">​</a></h3><p><strong>其核心思路如下：</strong></p><ol><li>用<code>this._committing</code> 表示程序是否处于 <code>commit</code> 执行过程。</li><li>用同步 watch（同步监听的意思是，一旦数据发生变化会立即调用回调，而不是在 <code>下一次 Tick</code> 中调用） 监听 store 中的 state 状态（深度监听）。</li><li>如果在 <code>commit</code> 执行过程中，state 发生了变化，在开发环境会报错。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_payload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">_options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_withCommit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // commit 中的处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      entry.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> commitIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  _withCommit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> committing</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._committing;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._committing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果函数内部有异步修改状态逻辑，则下面的 watch 时会报错</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._committing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> committing;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> enableStrictMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">store</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store._state.data,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (__DEV__) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 开发环境报错</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        assert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          store._committing,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          \`do not mutate vuex store state outside mutation handlers.\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    { deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, flush: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sync&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义同步的 watcher 进行同步监控</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_4、vuex-的-module-在什么情况下会使用" tabindex="-1">4、Vuex 的 module 在什么情况下会使用？ <a class="header-anchor" href="#_4、vuex-的-module-在什么情况下会使用" aria-label="Permalink to &quot;4、Vuex 的 module 在什么情况下会使用？&quot;">​</a></h2><p>用官方的话来说就是，<strong>“使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。”</strong></p><p>所以我们在开发复杂应用时，可以按照业务逻辑将应用状态进行 modules 拆分，比如：</p><ol><li>用户模块 user；</li><li>订单模块 order；</li><li>课程模块 course；</li><li>...等其它模块。</li></ol><p>这样在开发应用和维护状态时更加精细和清晰，可维护性更强。</p><h2 id="_5、vuex-和-pinia-的区别" tabindex="-1">5、Vuex 和 Pinia 的区别？ <a class="header-anchor" href="#_5、vuex-和-pinia-的区别" aria-label="Permalink to &quot;5、Vuex 和 Pinia 的区别？&quot;">​</a></h2><p><code>Pinia</code> 是以 <code>Vuex 5</code> 为原型，由 Vue.js 官方团队开发的新一代 Vue 官方推荐的状态管理方案。</p><p><strong>它对比 Vuex 有以下区别：</strong></p><h3 id="_5-1-api-设计和使用方式" tabindex="-1">5.1 API 设计和使用方式 <a class="header-anchor" href="#_5-1-api-设计和使用方式" aria-label="Permalink to &quot;5.1 API 设计和使用方式&quot;">​</a></h3><ul><li><strong>Vuex</strong>：采用单一 store 结构，需要严格区分 mutation（同步修改状态）和 action（异步操作）。状态修改必须通过 commit mutations 进行，虽然让数据流向更清晰，但也会让代码更加冗长。</li><li><strong>Pinia</strong>：更简单的 API 设计，所见即所得，也提供了符合组合式 API 风格的 API（比如用 defineStore 定义 store）。去掉了 mutation，直接在 actions 中修改 state（支持同步/异步）。</li></ul><h3 id="_5-2-模块化和结构" tabindex="-1">5.2 模块化和结构 <a class="header-anchor" href="#_5-2-模块化和结构" aria-label="Permalink to &quot;5.2 模块化和结构&quot;">​</a></h3><ul><li><strong>Vuex</strong>：支持模块化（modules），但需要在单一 store 中组织，可能导致大型项目 store 膨胀。</li><li><strong>Pinia</strong>：天生模块化，每个 store 独立定义和导入，支持动态注册和热重载。更适合大型应用，便于拆分成小 store。</li></ul><h3 id="_5-3-typescript-支持" tabindex="-1">5.3 TypeScript 支持 <a class="header-anchor" href="#_5-3-typescript-支持" aria-label="Permalink to &quot;5.3 TypeScript 支持&quot;">​</a></h3><ul><li><strong>Vuex</strong>：TypeScript 支持一般，需要额外配置；</li><li><strong>Pinia</strong>：本身源码就是用 TypeScript 编写，所以对TypeScript 支持十分友好，具备自动推断类型、类型安全和代码补全。</li></ul><h3 id="_5-4-性能和集成" tabindex="-1">5.4 性能和集成 <a class="header-anchor" href="#_5-4-性能和集成" aria-label="Permalink to &quot;5.4 性能和集成&quot;">​</a></h3><ul><li><strong>Vuex</strong>：Vuex4 在 Vue3 中可用，但与 Composition API 集成不够顺畅，可能需要额外的适配；</li><li><strong>Pinia</strong>：更轻量（体积小，约1kb），性能更好；完美支持 Vue 3 的 Composition API 和 reactivity 系统。</li></ul><h2 id="_6、pinia-和-vuex-如何选择" tabindex="-1">6、Pinia 和 Vuex 如何选择？ <a class="header-anchor" href="#_6、pinia-和-vuex-如何选择" aria-label="Permalink to &quot;6、Pinia 和 Vuex 如何选择？&quot;">​</a></h2><ul><li><strong>新项目</strong>：强烈推荐用 <code>Vue3 + Pinia</code>；</li><li><strong>老 Vue2 项目</strong>：如果不把项目升级到 Vue3 还是建议用 Vuex，如果需要升级到 vue3，就可以逐步把 Vuex 替换为 Pinia，Vuex 和 Pinia 是可以同时安装在同一个项目中，这也为项目升级提供了一定的便利。当然，由 <code>Vuex -&gt; Pinia</code>，是一次，无疑和 <code>Vue2 -&gt; Vue3</code> 一样，是一次大的破坏性升级，工作量还是相当大的。</li></ul>`,42)])])}const E=i(e,[["render",l]]);export{c as __pageData,E as default};
