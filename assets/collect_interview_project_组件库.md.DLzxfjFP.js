import{_ as e,c as i,o as t,ae as a}from"./chunks/framework.BKNbpbHR.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/interview/project/组件库.md","filePath":"collect/interview/project/组件库.md"}'),o={name:"collect/interview/project/组件库.md"};function r(n,l,s,c,u,d){return t(),i("div",null,[...l[0]||(l[0]=[a('<h2 id="你开发过组件库吗-说说你的设计思路和实现细节" tabindex="-1">你开发过组件库吗？说说你的设计思路和实现细节？ <a class="header-anchor" href="#你开发过组件库吗-说说你的设计思路和实现细节" aria-label="Permalink to &quot;你开发过组件库吗？说说你的设计思路和实现细节？&quot;">​</a></h2><h3 id="_1-架构设计" tabindex="-1">1. 架构设计 <a class="header-anchor" href="#_1-架构设计" aria-label="Permalink to &quot;1. 架构设计&quot;">​</a></h3><ul><li><p>分层</p><ul><li>rc-xxx: 基础组件，unstyled component（headless component），只具备功能交互，不具备 UI 表现</li><li>样式体系，theming，给 unstyled component 覆盖 UI 表现</li><li>基础组件：比如rc-xxx属于基础组件</li><li>复合组件 <ul><li>Search = Input + Select</li><li>IconButton = Icon + Button</li></ul></li><li>业务组件</li></ul></li><li><p>解耦</p><ul><li>对于每个组件都需要定义样式、ts类型、基础操作、工具方法</li></ul></li><li><p>响应式设计</p><ul><li>媒体查询 Media Query、ResizeObserver、Grid布局</li></ul><h3 id="_2-状态管理" tabindex="-1">2. 状态管理 <a class="header-anchor" href="#_2-状态管理" aria-label="Permalink to &quot;2. 状态管理&quot;">​</a></h3><ul><li>全局状态，基础配置、国际化配置、主题配置 <ul><li>react =&gt; Context、useSyncExternalStore</li><li>vue -&gt; vue-demi</li></ul></li><li>局部状态，表单场景，受控和非受控</li></ul></li></ul><blockquote><p>受控组件和非受控组件的区别：状态是否跟表单双向奔赴 受控 <code>input value={v} onChange={() =&gt; setV}</code> 非受控 <code>input defaultValue={v} onChange={() =&gt; setV}</code></p></blockquote><h3 id="_3-样式体系与主题设计" tabindex="-1">3. 样式体系与主题设计 <a class="header-anchor" href="#_3-样式体系与主题设计" aria-label="Permalink to &quot;3. 样式体系与主题设计&quot;">​</a></h3><ul><li>Color Tokens：颜色色值系统，（antd、arco | mantineUI | mui | shadcn/ui）</li><li>样式模块化方案：css-in-js（弊端：运行时消耗内存，ssr 不友好）【Emotion、styled-components】，module css</li><li>样式优先级与覆盖：控制样式优先级</li></ul><h3 id="_4-模块化" tabindex="-1">4. 模块化 <a class="header-anchor" href="#_4-模块化" aria-label="Permalink to &quot;4. 模块化&quot;">​</a></h3><ul><li>可复用性，对于 props、events 的设计非常重要，为什么 input、textarea 都需要 value onChange 成对</li><li>公共方法：颜色计算函数，格式化处理，本地化，工具函数 —— @ant-design/utils</li></ul><h3 id="_5-开发流程" tabindex="-1">5. 开发流程 <a class="header-anchor" href="#_5-开发流程" aria-label="Permalink to &quot;5. 开发流程&quot;">​</a></h3><h4 id="_5-1-本地开发" tabindex="-1">5.1 本地开发 <a class="header-anchor" href="#_5-1-本地开发" aria-label="Permalink to &quot;5.1 本地开发&quot;">​</a></h4><p>二次开发，基于 antd 二次开发</p><h4 id="_5-2-组件库开发流程" tabindex="-1">5.2 组件库开发流程 <a class="header-anchor" href="#_5-2-组件库开发流程" aria-label="Permalink to &quot;5.2 组件库开发流程&quot;">​</a></h4><ol><li>工程架构：monorepo，core + components + hooks + utils + shared</li><li>TypeScript</li><li>流程化、规范化、自动化</li></ol><ul><li>script 如何定义（CI、CD的源头）</li><li>eslint9、stylelint、spellcheck、commitlint</li><li>颜色值生成，自动构建，增量构建，构建换成</li></ul><ol start="4"><li>构建打包：rollup、esbuild、swc</li><li>测试，单元测试，vitest，jest + react-testing-library</li></ol>',15)])])}const _=e(o,[["render",r]]);export{p as __pageData,_ as default};
