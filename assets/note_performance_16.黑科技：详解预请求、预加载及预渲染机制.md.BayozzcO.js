import{_ as e,c as t,o as i,ae as p}from"./chunks/framework.Ba8ARF_W.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/performance/16.黑科技：详解预请求、预加载及预渲染机制.md","filePath":"note/performance/16.黑科技：详解预请求、预加载及预渲染机制.md"}'),r={name:"note/performance/16.黑科技：详解预请求、预加载及预渲染机制.md"};function l(o,a,n,_,h,s){return i(),t("div",null,[...a[0]||(a[0]=[p('<h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>在性能影响因素里，后端接口的耗时也不可忽略。以某电商 APP 列表页为例，后端接口返回数据需要 200ms，参考首屏秒开的标准，它就占了 20% 的时间。</p><p>以前一直采用的是缓存或者静态化的方案去解决，能不请求实时数据就不请求，用历史数据去代替。直到我遇到了机票和酒店相关的业务，因为它们的价格和库存会实时变化，如果页面打开时间长，用户会担心买不到合适的机票，转而离开去往竞品购买。</p><p>采用预请求、预加载和预渲染的方式来解决问题。</p><h2 id="预请求" tabindex="-1">预请求 <a class="header-anchor" href="#预请求" aria-label="Permalink to &quot;预请求&quot;">​</a></h2><p>想要通过拉取后端接口来降低首屏时间，我们需要先实现接口的预加载，而实现它要先解决预请求的逻辑，也就是统一拼装请求参数的逻辑。</p><p>具体怎么进行统一拼参呢？</p><p>以机票业务为例，进入列表页后，输入出发地和目的地后，比如从北京到深圳，选择日期为 2021-06-06，前端应用通过解析页面 URL 路径，拿到所需的一些参数。调用 Native 的 schema 进入参数解析环节，找到 Native 对应的协议和参数，然后再通过参数初始化，拼装成对应的参数。</p><p>面临的一个问题时，没有预请求的页面 URL 参数，也没法通过 Native 获取到。</p><p>我们使用了同样的流程，将预请求封装成 preReq 功能，把所有的功能都包括起来，用同一份代码实现。</p><ul><li>如果你已经使用了 Native 统一请求，直接走客户端逻辑发送即可。</li><li>如果没有走 Native 统一请求，我们可以借助 axios 库函数来完成。</li></ul><h2 id="预加载" tabindex="-1">预加载 <a class="header-anchor" href="#预加载" aria-label="Permalink to &quot;预加载&quot;">​</a></h2><p>在完成预请求参数拼装之后，紧接着就是预加载逻辑了，首先是要把握预加载的时机。以机票列表页为例，我们需要判断用户操作对的特定路径。如果用户命中了这个特定路径，就会走预加载去加载列表页的接口。</p><p>这个路径是我们和后端的一个约定，有具体的编号。比如用户进入首页编号是 0，输入出发地和目的地编号是 1，选择日期的编号是 2，切换关键词的编号是3。后端在用户进入页面页时，以接口的方式返回一个操作路径的数组，当用户的操作路径命中这个数组后，选择了出发地和目的地，并且输入了日期，接下来开始进行预加载。</p><p>当用户点击“开始搜索”后，前端应用就会去判断有没有预加载下级页面（搜索页面）的接口，是否有预加载数据，数据有没有过期。如果没有可用的预加载数据，此时我们进行一次搜索页的预加载，减少从列表页到搜索页的跳转时间和搜索页的初始化时间。</p><p>如果 Native 已经提供这个工具，我们直接使用 Native 的预加载接口即可，反之，我们还是需要扩展 axios 库函数来实现。在 axios 进行数据请求后，封装一个 afterFetch 的钩子方法，负责将加载完成的数据存储到内存/本地，供下一个路由使用。</p><h2 id="预渲染" tabindex="-1">预渲染 <a class="header-anchor" href="#预渲染" aria-label="Permalink to &quot;预渲染&quot;">​</a></h2><p>预渲染是指在用户访问这个页面之前，完成页面渲染的准备。</p><p>以机票列表页为例，比如说用户命中特定路径的时候，前端会进行判断并会把搜索结果页先渲染出来，只不过在列表页可视区域下方，用户是不可见的。</p><p>当用户点击开始搜索时，前端会去 check，如果已经有了预渲染的页面，只需要把页面显示出来的操作，push 到顶层即可，这样就省去了初始化页面、请求数据和渲染的时间。</p><p>“客户端”渲染技术：</p><ul><li>它有别于 CSR，而是NSR（Native side rendering，客户端渲染）</li></ul><p>NSR 是怎么实现的呢？</p><ul><li>首先是模板和数据的准备，用户点击页面链接进入后，这个页面的所有资源是准备好的，具体可以使用离线包或者预请求和预加载的方式。</li><li>由于页面是动态的而 URL 是静态的，需要实现一种页面和模板的映射机制，一般为多对一</li><li>在 Native 侧实现一种类似前文 SSR 方案的 Native 的本地渲染服务</li></ul><p>在使用时，前端代码不需要做什么改动，业务侧前端工程师接入 NSR，把后置流程准备好就可以了，所谓的后置流程，就是指渲染好下级页面后放置在可视区域之外。</p><h2 id="长列表性能优化" tabindex="-1">长列表性能优化 <a class="header-anchor" href="#长列表性能优化" aria-label="Permalink to &quot;长列表性能优化&quot;">​</a></h2><p>NSR 是在端内渲染的场景，如果是端外怎么办呢？端外就是纯前端的渲染了。</p><p>公司有个文档内容展现平台，在对文档进行展现时，需要用到虚拟页，即要展示的文档的页码会根据页面内容动态变化，这样同一篇文档，在不同平台上显示，需要切割分页，但该操作需要一定的时间。所以，最好的办法是，当展示第1页的时候，就预先渲染第3页的内容。在展示第T页的时候，在可视范围之外，做T+2页的数据切割，切割完进行渲染，渲染完成后放在原地，等点击第T+2页时，移动回来。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>以上就是预请求、预加载及预渲染相关的内容。</p><p>在实际当中，你可能会遇到预加载和预渲染需要降级的问题，比如没有拿到数据的兜底兼容流程，可以继续使用 CSR，同时如果在端外无法使用离线包，则使用 SSR 是一种很好的替代方案。</p>',31)])])}const u=e(r,[["render",l]]);export{d as __pageData,u as default};
