import{_ as a,c as o,o as r,ae as t}from"./chunks/framework.Ba8ARF_W.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/framework/vue/vue2/ssr.md","filePath":"note/framework/vue/vue2/ssr.md"}'),l={name:"note/framework/vue/vue2/ssr.md"};function d(i,e,c,n,s,u){return r(),o("div",null,[...e[0]||(e[0]=[t('<h2 id="项目改造注意点" tabindex="-1">项目改造注意点 <a class="header-anchor" href="#项目改造注意点" aria-label="Permalink to &quot;项目改造注意点&quot;">​</a></h2><ul><li>vue生命周期钩子只有<code>beforeCreate</code>和<code>created</code>能用</li><li>避免在 <code>beforeCreate</code> 和 <code>created</code> 生命周期时产生全局副作用的代码，比如你写了一个setInterval，客户端会在<code>beforeDestroy</code>或者<code>destroyed</code>中销毁，而服务端渲染中就没法销毁了，所以这种副作用的代码需要放在<code>beforeMount</code>或者<code>mounted</code>中。</li></ul><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><ul><li>使用无全局 window/document 的依赖 减少复杂度高的运算，避免 O(n ^2)</li></ul><h2 id="优化策略" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略" aria-label="Permalink to &quot;优化策略&quot;">​</a></h2><p>QPS是多少，如何提高吞吐</p><ul><li>缓存（真的需要缓存么？缓存利用率，考虑用户网络，不需要做组件这种细粒度的缓存，侵入业务代码导致可维护性下降）</li></ul><h2 id="降级策略" tabindex="-1">降级策略 <a class="header-anchor" href="#降级策略" aria-label="Permalink to &quot;降级策略&quot;">​</a></h2><ul><li>超过一定阈值，降级成CSR，也就是返回静态资源</li><li>网络抖动导致服务端某些数据拉取失败，要在客户端保证用户能看到全的数据</li></ul><h2 id="日志与告警" tabindex="-1">日志与告警 <a class="header-anchor" href="#日志与告警" aria-label="Permalink to &quot;日志与告警&quot;">​</a></h2><p>可观测，可追踪</p>',11)])])}const f=a(l,[["render",d]]);export{_ as __pageData,f as default};
