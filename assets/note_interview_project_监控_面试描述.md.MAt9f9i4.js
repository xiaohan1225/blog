import{_ as s,o as a,c as l,ae as e}from"./chunks/framework.h0LyDJ8h.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/interview/project/监控/面试描述.md","filePath":"note/interview/project/监控/面试描述.md"}'),t={name:"note/interview/project/监控/面试描述.md"};function n(h,i,r,k,p,o){return a(),l("div",null,[...i[0]||(i[0]=[e(`<h2 id="项目描述" tabindex="-1">项目描述 <a class="header-anchor" href="#项目描述" aria-label="Permalink to &quot;项目描述&quot;">​</a></h2><p>主导去调研了 Sentry 平台，Sentry 是业界非常主流和强大的产品，它里面提供了 xx 特性，我整体架构设计了监控平台 sdk、监控平台服务端、监控平台的数据清洗、数据处理、再到监控平台可视化引擎、可视化链路整个全链路的设计。</p><h2 id="指标体系设计" tabindex="-1">指标体系设计 <a class="header-anchor" href="#指标体系设计" aria-label="Permalink to &quot;指标体系设计&quot;">​</a></h2><ul><li>性能 <ul><li>CLS：累积布局偏移，衡量页面布局稳定性</li><li>LCP：最大内容绘制时间，衡量页面主要内容的加载速度</li><li>TTFP：首字节时间，衡量服务器的响应速度</li><li>INP：交互到下一次绘制的时间，衡量页面响应交互的速度</li><li>FP：首次向屏幕绘制内容的时间</li><li>FCP：浏览器首次绘制出内容元素的时间</li><li>FMP：首次绘制用户关注内容的时间（这个不是一个标准指标）</li></ul></li><li>异常 <ul><li>js 代码异常</li><li>异步处理异常</li><li>资源加载异常</li></ul></li><li>用户行为 <ul><li>也称为用户行为（事件 click mousedown）埋点，SDK（手工埋点、无痕埋点、可视化埋点）</li></ul></li><li>数据请求与资源 <ul><li>fetch、xhr 原型重写</li></ul></li></ul><h2 id="性能采集" tabindex="-1">性能采集 <a class="header-anchor" href="#性能采集" aria-label="Permalink to &quot;性能采集&quot;">​</a></h2><p>使用 web-vitals，这是标准化库。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { onLCP, onINP, onCLS } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;web-vitals&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="异常采集" tabindex="-1">异常采集 <a class="header-anchor" href="#异常采集" aria-label="Permalink to &quot;异常采集&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;error&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">lineno</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">colno</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 发送错误信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;unhandledrejection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">reason</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 发送错误信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>但这里需要考虑跨平台，不能把 window 写死。</p><p>GLOBAL_OBJ</p><ul><li>浏览器端 window</li><li>node 端 globalThis</li><li>小程序端</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCurrentScope</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window;</span></span></code></pre></div><h2 id="node-性能采集" tabindex="-1">Node 性能采集 <a class="header-anchor" href="#node-性能采集" aria-label="Permalink to &quot;Node 性能采集&quot;">​</a></h2><p>在 Node.js 中，我们可以使用 node:perf_hooks 模块来实现与 W3C Web Performance API 相关的功能。这些功能通常用于监控代码性能。帮助开发者理解代码执行的效率。Node.js支持以下几个Web性能API:</p><ol><li>High Resolution Time: 提供高精度的时间测量，可以精确到微秒级别。</li><li>Performance Timeline: 允许记录和观察代码运行的性能事件。</li><li>User Timing: 允许开发者为特定的代码片段标记时间，以便计算执行时长。</li><li>Resource Timing:用于收集和记录应用程序中加载资源的性能数据。</li></ol><h2 id="事件采集" tabindex="-1">事件采集 <a class="header-anchor" href="#事件采集" aria-label="Permalink to &quot;事件采集&quot;">​</a></h2><p>事件采集是用户操作行为监控的核心，包括对 DOM事件、XHR请求、Fetch请求等的采集。Sentry通过对原生方法的代理，捕获用户操作并记录在系统中。</p><p>事件类型：</p><ul><li>DOM事件：例如点击、键盘输入等用户操作。</li><li>XHR和Fetch请求：通过代理原生的XMLHttpRequest和fetch,捕获每个网络请求的详情，包括URL、响应时间、状态码等。</li><li>History和Navigation API事件：捕获页面导航行为，如前进、后退操作等。</li></ul><p>实现原理：</p><ul><li>我们可以通过重写addEventListener方法，来捕获用户在页面上进行的点击、键盘输入等操作。同时，通过代理XMLHttpRequest和fetch来拦截网络请求，并记录相关信息。</li><li>xhr：通过重写XMLHttpRequest.prototype.send方法，在发送请求前记录相关信息。</li><li>fetch：通过重写fetch方法，<code>window.fetch = xxx</code> 在发送请求前和请求完成后记录相关信息。</li></ul><h2 id="架构包" tabindex="-1">架构包 <a class="header-anchor" href="#架构包" aria-label="Permalink to &quot;架构包&quot;">​</a></h2><ul><li>packages/browser: 针对原生浏览器封装埋点上传sdk</li><li>packages/browser-utils: 浏览器端功能函数</li><li>packages/core: 整个监控 sdk 的核心层</li><li>packages/vue: 整个监控 sdk 在 vue 层的适配</li><li>packages/react: 整个监控 sdk 在 react 层的适配</li><li>packages/types: 整个监控 sdk 的类型定义</li><li>packages/utils: 整个监控 sdk 的处理函数</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>工程化设计</li><li>SDK 封装 <ul><li>指标采集（空闲时发送，发送队列）</li><li>指标上报</li></ul></li><li>SDK dsn server <ul><li>Kafka 来做消息队列 <ul><li>topics</li><li>partition</li></ul></li><li>clickhouse <ul><li>列式存储</li></ul></li><li>数据处理聚合统计</li></ul></li><li>监控 Sass 平台 <ul><li>创建应用</li><li>监控应用的指标</li></ul></li><li>CI/CD <ul><li>Docker</li></ul></li></ul><p>整体过程</p><ul><li>前端项目插入sdk，通过行为触发埋点</li><li>监控平台sdk上报服务端</li><li>服务端削峰限流（Kafka做中间层消息队列，消息队列去分发、削峰，保证服务稳定），数据清洗整合，落库 clickhouse</li><li>数据从 SDK 采集到 dsn 服务、入库 clickhouse、数据统计、监控平台服务数据消费全流程设计。</li></ul><h2 id="sdk数据采集与上报核心实现思路" tabindex="-1">SDK数据采集与上报核心实现思路 <a class="header-anchor" href="#sdk数据采集与上报核心实现思路" aria-label="Permalink to &quot;SDK数据采集与上报核心实现思路&quot;">​</a></h2><blockquote><p>我们主要讲解核心指标采集与监控数据整体流程，后续如果有需要自定义事件和数据采集的，可以借助MutationObserver或Performance API 进行处理</p></blockquote><h3 id="设计概要" tabindex="-1">设计概要 <a class="header-anchor" href="#设计概要" aria-label="Permalink to &quot;设计概要&quot;">​</a></h3><h4 id="核心模块设计" tabindex="-1">核心模块设计 <a class="header-anchor" href="#核心模块设计" aria-label="Permalink to &quot;核心模块设计&quot;">​</a></h4><p>要实现一个前端性能监控和异常埋点，我们需要以下几个核心模块：</p><ol><li>网页性能指标采集(FP、FCP、CLS等)：通过web-vitals采集这些性能指标。</li><li>异常采集：监控JS错误、资源加载错误和未捕获的Promise错误。</li><li>点击事件采集：捕获用户点击行为，记录交互路径。</li><li>基础信息采集：采集 IP、机型、系统、浏览器等设备及环境信息。</li><li>数据传输协议：统一封装不同类别的数据，发送给后端。</li></ol><h4 id="核心目标" tabindex="-1">核心目标 <a class="header-anchor" href="#核心目标" aria-label="Permalink to &quot;核心目标&quot;">​</a></h4><p>1 .插件化设计：支持性能、异常、点击事件等不同采集插件。 2. 跨环境兼容：支持浏览器和Node服务端的数据上报。 3. 代码解耦：数据传输逻辑与采集逻辑分离，方便维护与扩展。 4. Monorepo:多包管理模式，提升代码复用和管理效率。</p><h3 id="sdk核心架构设计" tabindex="-1">SDK核心架构设计 <a class="header-anchor" href="#sdk核心架构设计" aria-label="Permalink to &quot;SDK核心架构设计&quot;">​</a></h3><ul><li>@miaoma/monitor-sdk-core <ul><li>定义核心逻辑和Transport接口。数据处理、约束、协议定义、上层设计。</li><li>负责插件初始化与注册。</li></ul></li><li>@miaoma/monitor-sdk-browser <ul><li>浏览器相关插件：性能、异常、点击事件采集。</li><li>自定义浏览器 Transport 上报实现。</li></ul></li><li>@miaoma/monitor-sdk-browser-utils（为什么要单独抽离出一个包，比如vue、react等扩展包也属于浏览器端，里面的工具方法都可以抽象到这里） <ul><li>提供浏览器环境下的工具方法。</li></ul></li><li>@miaoma/monitor-sdk-node <ul><li>适配 Node 环境的 Transport 上报实现。</li></ul></li></ul><h2 id="项目目录" tabindex="-1">项目目录 <a class="header-anchor" href="#项目目录" aria-label="Permalink to &quot;项目目录&quot;">​</a></h2><ul><li>/views： 处理路由相关逻辑，和页面和路由的桥接层</li><li>/types/api: 后端接口返回的类型定义，比如 xxxPayload(post接口参数)、xxxParams(get请求参数)、xxxRes（返回值）</li></ul>`,40)])])}const u=s(t,[["render",n]]);export{c as __pageData,u as default};
