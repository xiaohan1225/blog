import{_ as a,o as i,c as t,ae as l}from"./chunks/framework.h0LyDJ8h.js";const c=JSON.parse('{"title":"004 React Hooks","description":"","frontmatter":{"title":"004 React Hooks","date":"2021-08-22T00:00:00.000Z","categories":["React"],"tags":["React"],"sidebar":"auto"},"headers":[],"relativePath":"note/framework/react/004.md","filePath":"note/framework/react/004.md"}'),e={name:"note/framework/react/004.md"};function n(h,s,k,p,o,r){return i(),t("div",null,[...s[0]||(s[0]=[l(`<h2 id="函数组件的特点" tabindex="-1">函数组件的特点 <a class="header-anchor" href="#函数组件的特点" aria-label="Permalink to &quot;函数组件的特点&quot;">​</a></h2><ul><li>没有组件实例</li><li>没有生命周期</li><li>没有state和setState，只能接收props</li></ul><h2 id="class组件的问题" tabindex="-1">class组件的问题 <a class="header-anchor" href="#class组件的问题" aria-label="Permalink to &quot;class组件的问题&quot;">​</a></h2><ul><li>大型组件很难拆分和重构，很难测试（即class不易拆分）</li><li>相同业务逻辑，分散到各个方法中，逻辑混乱（比如绑定和解绑事件分散在不同的生命周期中）</li><li>复用逻辑变得复杂，如Mixins（React中已废弃）、HOC、Render Prop</li></ul><h2 id="react组件更易用函数表达" tabindex="-1">React组件更易用函数表达 <a class="header-anchor" href="#react组件更易用函数表达" aria-label="Permalink to &quot;React组件更易用函数表达&quot;">​</a></h2><ul><li>React提倡函数式编程，view = fn（props）</li><li>函数更灵活，更易拆分，更易测试</li><li>但函数组件太简单，需要增强能力 —— Hooks</li></ul><h2 id="react-hooks" tabindex="-1">React Hooks <a class="header-anchor" href="#react-hooks" aria-label="Permalink to &quot;React Hooks&quot;">​</a></h2><ul><li>可选功能（class组件 vs Hooks）</li><li>100%向后兼容，没有破坏性改动</li><li>不会取代class组件，尚无计划要移除class组件</li></ul><p>hooks主要有哪些：</p><ul><li>State Hook</li><li>Effect Hook</li><li>其它Hook</li><li>自定义Hook</li></ul><h3 id="为什么会有react-hooks-它解决了哪些问题" tabindex="-1">为什么会有React Hooks，它解决了哪些问题？ <a class="header-anchor" href="#为什么会有react-hooks-它解决了哪些问题" aria-label="Permalink to &quot;为什么会有React Hooks，它解决了哪些问题？&quot;">​</a></h3><h3 id="react-hooks如何模拟组件生命周期" tabindex="-1">React Hooks如何模拟组件生命周期？ <a class="header-anchor" href="#react-hooks如何模拟组件生命周期" aria-label="Permalink to &quot;React Hooks如何模拟组件生命周期？&quot;">​</a></h3><h3 id="如何自定义hook" tabindex="-1">如何自定义Hook？ <a class="header-anchor" href="#如何自定义hook" aria-label="Permalink to &quot;如何自定义Hook？&quot;">​</a></h3><h3 id="react-hooks性能优化" tabindex="-1">React Hooks性能优化 <a class="header-anchor" href="#react-hooks性能优化" aria-label="Permalink to &quot;React Hooks性能优化&quot;">​</a></h3><h3 id="使用react-hooks遇到哪些坑" tabindex="-1">使用React Hooks遇到哪些坑？ <a class="header-anchor" href="#使用react-hooks遇到哪些坑" aria-label="Permalink to &quot;使用React Hooks遇到哪些坑？&quot;">​</a></h3><h3 id="hooks相比hoc和render-prop有哪些优点" tabindex="-1">Hooks相比HOC和Render Prop有哪些优点？ <a class="header-anchor" href="#hooks相比hoc和render-prop有哪些优点" aria-label="Permalink to &quot;Hooks相比HOC和Render Prop有哪些优点？&quot;">​</a></h3><h2 id="usestate-让函数组件实现state和setstate" tabindex="-1">useState：让函数组件实现state和setState <a class="header-anchor" href="#usestate-让函数组件实现state和setstate" aria-label="Permalink to &quot;useState：让函数组件实现state和setState&quot;">​</a></h2><ul><li>默认函数组件没有state</li><li>函数组件是一个纯函数，执行完即销毁，无法存储state</li><li>需要State Hook，即把state功能“钩”到纯函数中</li></ul><h2 id="useeffect-让函数组件模拟生命周期" tabindex="-1">useEffect：让函数组件模拟生命周期 <a class="header-anchor" href="#useeffect-让函数组件模拟生命周期" aria-label="Permalink to &quot;useEffect：让函数组件模拟生命周期&quot;">​</a></h2><ul><li>默认函数组件没有生命周期</li><li>函数组件是一个纯函数，执行完即销毁，自己无法实现生命周期</li><li>使用Effect Hook把生命周期“钩”到纯函数中</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模拟 class 组件的 DidMount 和 DidUpdate</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;在此发送一个 ajax 请求&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模拟 class 组件的 DidMount</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;挂载完了&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模拟 class 组件的 DidUpdate</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;更新了&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [count])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模拟 class 组件的 willUnMount</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> timer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        clearInterval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [])</span></span></code></pre></div><p>useEffect使用总结：</p><ul><li>模拟componentDidMount - useEffect 依赖[]</li><li>模拟componentDidUpdate - useEffect 无依赖，或者依赖[a, b]</li><li>模拟componentWillUnMount - useEffect 中返回一个函数</li></ul><p>useEffect让纯函数有了副作用：</p><ul><li>默认情况下，执行纯函数，输入参数，返回结果，无副作用</li><li>所谓副作用，就是对函数之外造成影响，如设置全局定时任务</li><li>而组件需要副作用，所有需要 useEffect “钩”入纯函数中</li></ul><blockquote><p>技术和业务有“矛盾”，通常是技术向业务“妥协”</p></blockquote>`,26)])])}const d=a(e,[["render",n]]);export{c as __pageData,d as default};
