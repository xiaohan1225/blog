import{_ as i,o as e,c as a,ae as o}from"./chunks/framework.h0LyDJ8h.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/performance/7.平台实践：如何从0到1搭建前端性能平台.md","filePath":"note/performance/7.平台实践：如何从0到1搭建前端性能平台.md"}'),r={name:"note/performance/7.平台实践：如何从0到1搭建前端性能平台.md"};function t(n,l,p,s,_,d){return e(),a("div",null,[...l[0]||(l[0]=[o('<h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>已经介绍了首屏时间、白屏、卡顿等性能指标采集和上报，接下来就该对性能 SDK 上报数据的处理了。</p><p>奥林匹亚项目：</p><ul><li>用的是一个开源的监控平台，只能够满足首屏时间和白屏时间等性能关键指标的展示需求，具体到一些个性化细分的数据，比如秒开率、数据瀑布流等并无法满足。</li><li>加上业务开始对性能重视起来，希望能提前发现故障，快速定位问题，于是前端性能平台的自研需求就应运而生了。</li></ul><p>什么是前端性能平台呢？</p><ul><li>前端性能平台是一个 Web 系统，主要包括后台的性能数据处理和前台的可视化展示两部分。</li></ul><p>数据处理后台主要是对 SDK 上报后的性能指标进行处理和运算，具体包括数据入库、数据清洗、数据计算。</p><p>技术架构：</p><ol><li>React + Ant Design + Antv + Less（平台层）</li><li>NodeJS + Node-schedule + Node-mailer（数据接入层）</li><li>Kafka + Spark + Hive + HDFS（数据计算层）</li><li>Mysql + mongoDB（存储层）</li></ol><h2 id="性能数据处理后台" tabindex="-1">性能数据处理后台 <a class="header-anchor" href="#性能数据处理后台" aria-label="Permalink to &quot;性能数据处理后台&quot;">​</a></h2><ul><li>客户端借助 SDK 上报性能数据指标，数据接入层接收的对应数据，并做协议转换等简单处理后，作为生产者向 Kafka 写入数据。</li><li>数据计算层作为消费者，从 Kafka 读数据存入 Hive，Hadoop 平台借助 Spark 做数据分析计算。</li><li>借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台，平台层取出数据，准备数据可视化展示的数据。</li></ul><ol><li>客户端借助 SDK 上报性能数据指标，需要后端服务层的处理，这里我们选取的是 NodeJS 做后端，利用 Controller 层对数据做处理。</li></ol><ul><li>将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。然后将数据写入消息队列 Kafka。</li></ul><p>为什么不是直接存入 Hive 呢？</p><ul><li>因为客户端上报对的性能数据量和用户规模有关，如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。</li><li>最好选择 Kafka，先让数据写进消息队列，Kafka 能通过缓存，慢慢接收这些数据，降低流量洪峰压力，同时可以避免数据重复的问题。</li></ul><ol start="2"><li>对 Kafka 中的数据，做数据清洗和数据计算 数据清洗是指针对单条上报数据进行合并校验的过程。</li></ol><ul><li>对重复数据的处理。比如同一用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据。</li><li>对缺失数据的处理。虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出。</li><li>对错误数据的处理。即数据超出正常范围，负值或者极大值的情况。</li></ul><p>这几种数据问题如果不处理，最终会影响计算结果的准确性。</p><p>那么如何处理呢？</p><ul><li>遇到重复数据，直接去重删除即可。</li><li>遇到缺失数据，在 Spark 平台上根据上报的 Performance 数据进行计算补全，如果无法补全的，直接舍弃掉，不然会出现无法入库的情况。</li><li>遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据把它当作无效数据，直接舍弃掉。</li></ul><p>还需要使用 Spark 做数据计算，为可视化展现准备数据</p><ul><li>首屏时间分布的计算，1s ~ 2s 占比多少，2s ~ 4s 占比多少。</li><li>秒开率的计算，首屏时间小于等于 1s 的数据占比。</li><li>页面瀑布流时间的计算。（是对首屏时间的细分，包括 DNS 查询、TCP连接、请求耗时、内容传输、资源解析、DOM解析和资源加载等时间，细分时间点事根据SDK上报的 Performance 接口数据指标计算出来的，前端工程师根据页面瀑布流时间，可以快速定位性能瓶颈点出现在哪个环节。）</li></ul><ol start="3"><li>准备性能前台所需要的可视化数据</li></ol><ul><li>性能平台需要登录功能，还需要做一些用户关注的模块信息，可以用关系数据库去存储这些数据。具体可以使用 mysql 完成账号权限系统和关注页面模块对应的数据表。</li><li>性能数据相互之间并没有什么关系，可以用 MongoDB 做存储。可以用 Nodejs 提供的定时脚本 Node-schedule 从 Spark 中取到数据，导入到 MongoDB 中。</li></ul><h2 id="前端数据可视化展示前台" tabindex="-1">前端数据可视化展示前台 <a class="header-anchor" href="#前端数据可视化展示前台" aria-label="Permalink to &quot;前端数据可视化展示前台&quot;">​</a></h2><p>主要包括大盘野和详情页。</p><ul><li>大盘页包括一个个业务的性能简图，每一个性能简图包括首屏时间、秒开率、采样 PV 数据。点击简图可以进入详情页。初次进入大盘页的时候，如果你登录并关注相关的业务，就可以在大盘首页看到相应的业务情况。</li><li>详情页的设计初衷是为了对性能简图做进一步的数据补充，除了展示性能简图的秒开率、白屏均值细节之外，还会展示终端信息，比如多少比例（PV）在 IOS 端，多少比例在 Android，以方面用户根据不同的场景做优化，同时为了了解秒开率不达标或者首屏时间变慢的细节在哪里，我们会给出页面加载瀑布流时间。</li></ul><p>前端技术栈选择：</p><ul><li>前端数据可视化展示前台主要是给公司前端开发者使用，功能上更多是数据可视化展示，非常适合用 React 技术栈做开发。</li><li>为了更好实现首屏时间、秒开率和采用 PC 的功能效果，我们使用 AntdPro 的模板，相关的数据可视化方面推荐用 Antv，因为它能够满足我们在首屏时间、秒开率等性能指标的展示需求，用起来也比较简单，功能灵活且扩展性强。</li><li>大盘页和详情页的数据展示效果比较丰富多样，相应的 CSS 代码逻辑就比较复杂，CSS 方面可以选用 Less 框架。</li><li>前后端交互方面，为了让前后台更独立，大盘页和详情页和后端的通讯通过 HTTP 接口来实现，使用 nginx 作为 Web Server。为了传输更加高效，我们使用 compression 对HTTP传输内容进行 gzip 压缩处理。</li><li>后台服务部分为了让性能平台开发过程更简单，效率更高，后台服务方面可以选用 Egg.js 做开发，进行数据处理和存储服务。</li><li>为了解决监控预警的问题，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。</li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>以上就是性能监控平台的核心实现，如果公司没有类似的埋点平台，可以参照这个进行实现，如果有了，性能上报直接走埋点平台处理就好，可以专注于前端数据可视化展示部分。</p><p>性能指标有很多内容，比如 DOM Ready 指标，完全加载时间指标，这些通过 performance 接口也能取到，但根据过往的经验，最有用的性能指标还是秒开率、首屏时间、白屏时间、卡顿指标。</p><p>问题：业界在统计首屏时间时，都会统计一下是否首次访问，这个是怎么实现的呢？</p>',33)])])}const S=i(r,[["render",t]]);export{c as __pageData,S as default};
