import{_ as s,c as a,o as e,ae as n}from"./chunks/framework.7E1nAy7n.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/performance/首屏优化.md","filePath":"collect/performance/首屏优化.md"}'),l={name:"collect/performance/首屏优化.md"};function t(h,i,r,o,p,d){return e(),a("div",null,[...i[0]||(i[0]=[n(`<p>在前端面试中，首屏优化一直是常见的前端性能面试题。</p><p>我们可以先用 <code>performance 相关API</code> 来统计下页面的 <code>DOM 加载时间</code>。</p><p>旧版统计方法，使用 <code>performance</code>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 旧版统计性能 performance.timing 已废弃，不推荐使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(performance.timing.domComplete </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.timing.navigationStart);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>新版统计方法，使用 <code>PerformanceObserver</code> (推荐使用):</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 新版统计性能 推荐使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> observer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PerformanceObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEntries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">entry</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(entry.domComplete);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ entryTypes: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;navigation&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>如果 <code>DOM加载时间</code> 过长，比如超过 1s，就需要考虑进行优化了，优化的话主要从以下几个方向进行：</p><ul><li>网络资源请求</li><li>构建工具</li><li>渲染</li><li>用户体验</li></ul><h2 id="一、网络资源请求" tabindex="-1">一、网络资源请求 <a class="header-anchor" href="#一、网络资源请求" aria-label="Permalink to &quot;一、网络资源请求&quot;">​</a></h2><h3 id="_1-1-减少请求个数" tabindex="-1">1.1 减少请求个数 <a class="header-anchor" href="#_1-1-减少请求个数" aria-label="Permalink to &quot;1.1 减少请求个数&quot;">​</a></h3><ul><li>图片采用 <code>雪碧图(CSS Sprites)</code>，<code>base64</code>，<code>WebP</code>，图片懒加载，只加载可视区域内的图片。</li><li>某些关键 CSS 可以采用 <code>style</code> 标签内联的方式，减少 CSS 资源请求数量。</li><li>某些数据及时性要求没那么高，可以增加接口缓存，减少请求次数。</li></ul><h3 id="_1-2-加快请求速度" tabindex="-1">1.2 加快请求速度 <a class="header-anchor" href="#_1-2-加快请求速度" aria-label="Permalink to &quot;1.2 加快请求速度&quot;">​</a></h3><ul><li>将图片进行压缩，减少图片大小</li><li>将静态资源 <code>html、css、js 以及图片</code> 都上传到 <code>cdn</code>。</li></ul><h2 id="二、构建工具" tabindex="-1">二、构建工具 <a class="header-anchor" href="#二、构建工具" aria-label="Permalink to &quot;二、构建工具&quot;">​</a></h2><p>这里以 <code>webpack</code> 为例。</p><h3 id="_2-1-按需打包" tabindex="-1">2.1 按需打包 <a class="header-anchor" href="#_2-1-按需打包" aria-label="Permalink to &quot;2.1 按需打包&quot;">​</a></h3><p>对于一些第三方包，我们有时候并不会用到包里全部的内容，这时候就可以根据自己使用的部分进行按需打包，以减少打包后的文件体积。比如 <code>Element-UI、Vant</code> 等组件库、<code>lodash、moment</code> 等三方包。</p><h3 id="_2-2-代码分割-splitchunks" tabindex="-1">2.2 代码分割 splitChunks <a class="header-anchor" href="#_2-2-代码分割-splitchunks" aria-label="Permalink to &quot;2.2 代码分割 splitChunks&quot;">​</a></h3><p>可以手动配置 <code>splitChunks</code> 进行代码分割：</p><ol><li>将一些不怎么变动的包提取到一起，提高缓存复用率。</li><li>一些比较大的包，可以单独进行代码分割，按需加载</li><li>使用<strong>异步组件</strong>和<strong>异步路由</strong>会自动进行代码分割，推荐将路由都设置为异步加载，一些比较大的组件，可以定义为异步组件，按需再加载。</li></ol><h3 id="_2-3-配置-externals" tabindex="-1">2.3 配置 externals <a class="header-anchor" href="#_2-3-配置-externals" aria-label="Permalink to &quot;2.3 配置 externals&quot;">​</a></h3><p><code>externals</code> 的作用是可以让某些特定的依赖不打包到最终的 <code>bundle</code> 中，这样可以大大减少打包后的包体积。</p><h3 id="_2-4-开启-tree-shaking" tabindex="-1">2.4 开启 tree-shaking <a class="header-anchor" href="#_2-4-开启-tree-shaking" aria-label="Permalink to &quot;2.4 开启 tree-shaking&quot;">​</a></h3><p><code>tree-shaking</code> 摇树优化能<strong>消除未使用的代码</strong>，减少打包体积。</p><h3 id="_2-5-开启-gzip-压缩" tabindex="-1">2.5 开启 gzip 压缩 <a class="header-anchor" href="#_2-5-开启-gzip-压缩" aria-label="Permalink to &quot;2.5 开启 gzip 压缩&quot;">​</a></h3><p>可以使用 <code>compression-webpack-plugin</code> 在打包过程中对资源文件进行压缩，并在服务器开启 <code>gzip</code>，比如如果前端静态资源服务器用的 <code>nginx</code>，就需要修改 <code>nginx</code> 配置。</p><h2 id="三、渲染层面" tabindex="-1">三、渲染层面 <a class="header-anchor" href="#三、渲染层面" aria-label="Permalink to &quot;三、渲染层面&quot;">​</a></h2><h3 id="_3-1-预渲染-prerendering" tabindex="-1">3.1 预渲染(Prerendering) <a class="header-anchor" href="#_3-1-预渲染-prerendering" aria-label="Permalink to &quot;3.1 预渲染(Prerendering)&quot;">​</a></h3><p>预渲染就是在构建时生成静态的 HTML，相比于单页应用需要在加载完 javascript 后再通过 js 渲染的方式，预渲染的首屏加载速度会快很多，而且 SEO 也更友好。</p><blockquote><p>适用场景：内容基本静态的页面，且需要更好的用户体验和 SEO 友好。</p></blockquote><h3 id="_3-2-服务端渲染-server-side-rendering" tabindex="-1">3.2 服务端渲染(Server-Side Rendering) <a class="header-anchor" href="#_3-2-服务端渲染-server-side-rendering" aria-label="Permalink to &quot;3.2 服务端渲染(Server-Side Rendering)&quot;">​</a></h3><p>服务端渲染（Server-Side Rendering，简称 SSR）是一种在服务器端将 <code>Vue</code> 组件渲染成<code>HTML 字符串</code>的技术。它在服务端拼接好 <code>HTML字符串</code>，然后发送给客户端，客户端无需等待下载和执行 <code>javascript</code>，可以直接渲染页面，这样能极大提升首屏渲染速度，SEO也更为友好。</p><blockquote><p>适用场景：需要优化 SEO，对首屏性能敏感，内容安全性高，能接受服务端渲染需要的额外服务器成本。</p></blockquote><h2 id="四、用户体验" tabindex="-1">四、用户体验 <a class="header-anchor" href="#四、用户体验" aria-label="Permalink to &quot;四、用户体验&quot;">​</a></h2><h3 id="_4-1-骨架屏-skeleton-screen" tabindex="-1">4.1 骨架屏(Skeleton Screen) <a class="header-anchor" href="#_4-1-骨架屏-skeleton-screen" aria-label="Permalink to &quot;4.1 骨架屏(Skeleton Screen)&quot;">​</a></h3><p>骨架屏是在内容加载前展示页面的大致结构框架，用于提升用户感知性能。</p><blockquote><p>注意点：骨架屏最好是需要在打包时直接注入到 html 中，那种组件库里面的骨架屏组件的渲染太靠后了，比如 Vant 的 <code>&lt;van-skeleton&gt;</code> 组件，其效果会差很多。</p></blockquote><h3 id="_4-2-懒加载" tabindex="-1">4.2 懒加载 <a class="header-anchor" href="#_4-2-懒加载" aria-label="Permalink to &quot;4.2 懒加载&quot;">​</a></h3><ul><li>图片懒加载: 只加载可视区域内的图片。</li><li>路由懒加载: 只加载当前路由的资源。</li><li>组件懒加载: 只加载当前用到的组件。</li><li>第三方库懒加载: 使用动态 import 加载第三方库。</li><li>按需加载样式/脚本: 以动态创建 <code>script标签/link标签</code> 的方式按需加载脚本/样式。</li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文介绍了首屏优化的一些思路和方案，主要从 <code>网络资源请求</code>、<code>构建工具</code>、<code>渲染</code> 和 <code>用户体验</code> 四方面进行优化。</p><ul><li>网络资源请求：减少请求个数和加快请求速度。</li><li>构建工具：通过按需打包、代码分割、externals、tree-shaking、gzip 等方式进行优化。</li><li>渲染：通过预渲染/服务端渲染提高首屏速度。</li><li>用户体验：通过骨架屏和懒加载，提高用户体验。</li></ul>`,42)])])}const E=s(l,[["render",t]]);export{c as __pageData,E as default};
