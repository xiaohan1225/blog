import{_ as a,c as t,o as i,ae as e}from"./chunks/framework.CqlM4162.js";const l="/blog/assets/HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4.BNItA3kI.webp",n="/blog/assets/HTTP%E5%93%8D%E5%BA%94%E5%A4%B4.CExUuv-L.webp",k=JSON.parse('{"title":"002 HTTP的报文结构","description":"","frontmatter":{"title":"002 HTTP的报文结构","date":"2021-07-21T00:00:00.000Z","categories":["网络协议"],"tags":["HTTP"],"sidebar":"auto"},"headers":[],"relativePath":"collect/net/002.md","filePath":"collect/net/002.md"}'),o={name:"collect/net/002.md"};function r(p,s,h,d,c,T){return i(),t("div",null,s[0]||(s[0]=[e('<h2 id="http是什么" tabindex="-1">HTTP是什么？ <a class="header-anchor" href="#http是什么" aria-label="Permalink to &quot;HTTP是什么？&quot;">​</a></h2><p>HTTP全称叫HyperText Transfer Protocol、<strong>超文本传输协议</strong>。其中<strong>超文本</strong>指代的是文本、超链接、音频、视频、图片等的统称，<strong>传输</strong>指的是把一堆东西从一个点搬到另一个点，<strong>协议</strong>有两个特点，第一点，必须要有两个或多个参与者，也就是“协”，第二点，协议是对参与者的一种行为约定和规范，也就是“议”。</p><p>综上所述，可以将HTTP的概念概括为：<strong>HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</strong></p><p>HTTP的传输工作由底层的TCP/IP来负责，那HTTP主要负责做些什么呢？</p><p>那就要从它的<strong>报文结构（header+body）</strong> 讲起了，HTTP协议在规范文档详细定义了报文的格式，规定了组成部分、解析规则、处理策略等，可以在TCP/IP层之上实现连接控制、缓存管理、数据编码、内容协商等功能。</p><h2 id="请求行" tabindex="-1">请求行 <a class="header-anchor" href="#请求行" aria-label="Permalink to &quot;请求行&quot;">​</a></h2><p>请求行（request line）表示<strong>客户端想要如何操作服务器端的资源</strong>。请求行 = 请求方法 + 请求目标 + 版本号，三个部分用空格来分隔，最后用CRLF换行表示结束。比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GET</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HTTP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span></code></pre></div><h2 id="状态行" tabindex="-1">状态行 <a class="header-anchor" href="#状态行" aria-label="Permalink to &quot;状态行&quot;">​</a></h2><p>状态行（status line）表示<strong>服务器响应的状态</strong>。状态行 = 版本号 + 状态码 + 原因短语。也是用空格分隔，行尾用CRLF表示结束。比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">HTTP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OK</span></span></code></pre></div><h2 id="头部字段" tabindex="-1">头部字段 <a class="header-anchor" href="#头部字段" aria-label="Permalink to &quot;头部字段&quot;">​</a></h2><p>请求头 = 请求行 + 头部字段集合，如下图： <img src="'+l+'" alt="图片加载失败"></p><p>响应头 = 响应行 + 头部字段集合，如下图： <img src="'+n+'" alt="图片加载失败"></p><p>头部字段是key-value的形式，key和value之间用“：”分隔，最后用CRLF换行表示字段结束。HTTP头字段比较灵活，可以添加自定义头，但需要注意：</p><ol><li>字段名不区分大小写</li><li>字段名中不允许出现空格和下划线“_”</li><li>字段名后面必须紧接着“：”，不能有空格，而“：”后的字段值前可以有多个空格</li><li>字段的顺序没有意义</li></ol><h2 id="常用头字段" tabindex="-1">常用头字段 <a class="header-anchor" href="#常用头字段" aria-label="Permalink to &quot;常用头字段&quot;">​</a></h2><p>HTTP的头字段可以分为四大类：</p><ol><li>通用字段：既可以作请求头也可以作为响应头</li><li>请求字段：仅能出现在请求头，说明请求信息和额外的附加条件</li><li>响应字段：仅能出现在响应头中，补充说明响应报文的信息</li><li>实体字段：它实际上属于通用字段，但专门描述body的额外信息</li></ol><p>下面介绍几个常见的头字段：</p><ol><li>Host字段。它属于请求字段，是唯一一个HTTP/1.1规范里要求<strong>必须出现</strong>的字段。</li><li>User-Agent字段。它属于请求字段，使用一个字符串来描述发起的HTTP请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。</li><li>Date字段。它属于通用字段，表示HTTP报文创建的时间，客户端可以使用这个时间再搭配其他字段决定缓存策略。</li><li>Server字段。它属于响应字段，告诉客户端当前正在提供Web服务的软件名称和版本号。</li><li>Content-Length。它属于实体字段，表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。如果没有这个字段，则表示body是不定长的，需要使用分块（chunked）方式分段传输。</li></ol>',21)]))}const P=a(o,[["render",r]]);export{k as __pageData,P as default};
