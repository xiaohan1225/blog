import{_ as i,c as t,o as a,ae as e}from"./chunks/framework.BFe6FF_l.js";const g=JSON.parse('{"title":"006 编程语言语言标识与JavaScript语言设计","description":"","frontmatter":{"title":"006 编程语言语言标识与JavaScript语言设计","date":"2021-10-26T00:00:00.000Z","categories":["JavaScript"],"tags":["JS基础"],"sidebar":"auto"},"headers":[],"relativePath":"collect/javascript/js-base/006.md","filePath":"collect/javascript/js-base/006.md"}'),o={name:"collect/javascript/js-base/006.md"};function s(n,l,r,u,c,p){return a(),t("div",null,[...l[0]||(l[0]=[e(`<h2 id="语言按语法分类" tabindex="-1">语言按语法分类 <a class="header-anchor" href="#语言按语法分类" aria-label="Permalink to &quot;语言按语法分类&quot;">​</a></h2><ul><li>非形式语言 <ul><li>中文，英文</li></ul></li><li>形式语言（乔姆斯基谱系） <ul><li>0型 无限制文法</li><li>1型 上下文相关文法：一个词的意思和上下文相关</li><li>2型 上下文无关文法：一个词的意思和上下文无关。<strong>大部分的计算机语言都是主体上的上下文无关语法</strong>。比如JavaScript语言不是上下文无关文法，它会在某一些小的点违法上下文无关文法，但它99%都是上下文无关文法。这样做不至于让做编译器的人太难受。</li><li>3型 正则文法，简单概括就是能用正则解析的文法。</li></ul></li></ul><blockquote><p>this在于语义上的多变，但是语法是一致的。</p></blockquote><h2 id="产生式-bnf" tabindex="-1">产生式（BNF） <a class="header-anchor" href="#产生式-bnf" aria-label="Permalink to &quot;产生式（BNF）&quot;">​</a></h2><ul><li>用尖括号括起来的名称来表示语法结构名</li><li>语法结构分成<strong>基础结构</strong>和需要用其他语法结构定义的<strong>复合结构</strong><ul><li>基础结构称终结符</li><li>复合结构称非终结符</li></ul></li><li>引号和中间的字符表示终结符</li><li>可以有括号</li><li><code>*</code>表示重复多次</li><li><code>|</code>表示或</li><li><code>+</code>表示至少一次</li></ul><p>四则运算：</p><ul><li>1 + 2 * 3</li></ul><p>终结符：</p><ul><li>Number</li><li><code>+ - * /</code></li></ul><p>非终结符：</p><ul><li>MultiplicativeExpression</li><li>AdditiveExpression</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&lt;number&gt; = &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot;...</span></span>
<span class="line"><span>&lt;DecimalNumber&gt; = &quot;0&quot; | (&quot;1&quot; | &quot;2&quot; | &quot;3&quot; ...) &lt;number&gt;*</span></span>
<span class="line"><span>&lt;Expression&gt; = &lt;DecimalNumber&gt; | &lt;DecimalNumber&gt; &quot;+&quot; &lt;Expression&gt;</span></span>
<span class="line"><span>&lt;AdditiveExpression&gt; = &lt;DecimalNumber&gt; | &lt;DecimalNumber&gt; &quot;+&quot; &lt;AdditiveExpression&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;MultiplicativeExpression&gt; = &lt;DecimalNumber&gt; | &lt;DecimalNumber&gt; &quot;*&quot; &lt;MultiplicativeExpression&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1 + 2 * 3:</span></span>
<span class="line"><span>&lt;AdditiveExpression&gt; = &lt;MultiplicativeExpression&gt; | &lt;DecimalNumber&gt; &quot;+&quot; &lt;MultiplicativeExpression&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;LogicalExpression&gt; = &lt;AdditiveExpression&gt; | &lt;AdditiveExpression&gt; &quot;||&quot; &lt;LogicalExpression&gt; | &lt;AdditiveExpression&gt; &quot;&amp;&amp;&quot; &lt;LogicalExpression&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;PrimaryExpression&gt; = &lt;DecimalNumber&gt; | &quot;(&quot; &lt;LogicalExpression&gt; &quot;)&quot;</span></span></code></pre></div><p>通过产生式理解乔姆斯基谱系：</p><ul><li>0型 无限制文法 <ul><li><code>?::=?</code></li></ul></li><li>1型 上下文相关文法 <ul><li><code>?&lt;A&gt;?::=?&lt;B&gt;?</code></li></ul></li><li>2型 上下文无关文法 <ul><li><code>&lt;A&gt;::=?</code></li></ul></li><li>3型 正则文法 <ul><li><code>&lt;A&gt;::=&lt;A&gt;?</code></li><li>错误文法：<code>&lt;A&gt;::=?&lt;A&gt;</code></li></ul></li></ul><p>JavaScript中有少量文法是上下文相关文法，比如<code>{ get a {return 1}, get: 1 }</code>，其中get在不同的上下文中意思不同，前者是可以作为属性修饰符，后者则是作为属性名。</p><h2 id="现代语言的特例" tabindex="-1">现代语言的特例 <a class="header-anchor" href="#现代语言的特例" aria-label="Permalink to &quot;现代语言的特例&quot;">​</a></h2><ul><li>C++中，<code>*</code>可能表示乘号或者指针，具体是哪个，取决于星号前面的标识符是否被声明为类型</li><li>VB中，<code>&lt;</code>可能是小于号，也可能是XML直接量的开始，取决于当前位置是否可以接受XML直接量</li><li>Python中，行首的tab符合空格会根据上一行的行首空白以一定规则被处理成虚拟终结符indent或者dedent</li><li>JavaScript中，<code>/</code>可能是除号，也可能是正则表达式开头，处理方式类似于VB，字符串模板中也需要特殊处理<code>}</code>，还有自动插入分号规则</li></ul><h2 id="图灵完备性" tabindex="-1">图灵完备性 <a class="header-anchor" href="#图灵完备性" aria-label="Permalink to &quot;图灵完备性&quot;">​</a></h2><ul><li>命令式——图灵机 <ul><li>goto</li><li>if和while</li></ul></li><li>声明式——lambda <ul><li>递归</li></ul></li></ul><h2 id="动态与静态" tabindex="-1">动态与静态 <a class="header-anchor" href="#动态与静态" aria-label="Permalink to &quot;动态与静态&quot;">​</a></h2><ul><li>动态： <ul><li>在用户的设备/在线服务器上</li><li>产品实际运行时</li><li>Runtime</li></ul></li><li>静态： <ul><li>在程序员的设备上</li><li>产品开发时</li><li>CompileTime</li></ul></li></ul><blockquote><p>编程：自己写代码。元编程：写一个程序生成代码。</p></blockquote><h2 id="类型系统" tabindex="-1">类型系统 <a class="header-anchor" href="#类型系统" aria-label="Permalink to &quot;类型系统&quot;">​</a></h2><ul><li>动态类型系统与静态类型系统</li><li>强类型与弱类型 <ul><li>String + Number（Number隐式转成String）</li><li>String == Boolean（Boolean先转成Number，再转成String）</li></ul></li><li>复合类型 <ul><li>结构体。比如对象 <code>{ a: T1, b: T2 }</code></li><li>函数签名。比如 <code>(T1, T2) =&gt; T3</code>，参数的数量、类型、类型所处的位置不对，都会造成函数签名的不匹配</li></ul></li><li>子类型 <ul><li>逆变/协变。协变：凡是能用<code>Array&lt;Parent&gt;</code>的地方，都能用<code>Array&lt;Child&gt;</code>。逆变：凡是能用<code>Function&lt;Child&gt;</code>的地方，都能用<code>Function&lt;Parent&gt;</code>。</li></ul></li></ul><p>强弱类型语言的区分在于<strong>有无隐式类型转换</strong>。比如C++是弱类型语言，ts也是弱类型语言。</p><h2 id="一般命令式编程语言" tabindex="-1">一般命令式编程语言 <a class="header-anchor" href="#一般命令式编程语言" aria-label="Permalink to &quot;一般命令式编程语言&quot;">​</a></h2><h3 id="atom-原子" tabindex="-1">Atom（原子） <a class="header-anchor" href="#atom-原子" aria-label="Permalink to &quot;Atom（原子）&quot;">​</a></h3><ul><li>Identifier</li><li>Literal</li></ul><h3 id="expression" tabindex="-1">Expression <a class="header-anchor" href="#expression" aria-label="Permalink to &quot;Expression&quot;">​</a></h3><ul><li>Atom</li><li>operator</li><li>Punctuator</li></ul><h3 id="statement" tabindex="-1">Statement <a class="header-anchor" href="#statement" aria-label="Permalink to &quot;Statement&quot;">​</a></h3><ul><li>Expression</li><li>Keyword</li><li>Punctuator</li></ul><h3 id="structure" tabindex="-1">Structure <a class="header-anchor" href="#structure" aria-label="Permalink to &quot;Structure&quot;">​</a></h3><ul><li>Function</li><li>Class</li><li>Process</li><li>Namespace</li><li>....</li></ul><h3 id="program" tabindex="-1">Program <a class="header-anchor" href="#program" aria-label="Permalink to &quot;Program&quot;">​</a></h3><ul><li>Program</li><li>Module</li><li>Package</li><li>Library</li></ul><blockquote><p>JavaScript的Program只有Program和Module。</p></blockquote>`,37)])])}const h=i(o,[["render",s]]);export{g as __pageData,h as default};
