import{_ as l,c as a,o as i,ae as o}from"./chunks/framework.BezmCoJM.js";const n=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/interview/project/vue ssr.md","filePath":"collect/interview/project/vue ssr.md"}'),r={name:"collect/interview/project/vue ssr.md"};function t(u,e,c,d,s,S){return i(),a("div",null,[...e[0]||(e[0]=[o('<h2 id="服务端渲染概念" tabindex="-1">服务端渲染概念 <a class="header-anchor" href="#服务端渲染概念" aria-label="Permalink to &quot;服务端渲染概念&quot;">​</a></h2><p>服务端渲染（Server-Side Rendering，简称 SSR）是一种在服务器端将 Vue 组件渲染成 HTML 字符串的技术。在服务器端渲染完成后，将生成的 HTML 字符串发送到客户端，客户端只需要解析 HTML 字符串即可，无需等待 <code>JavaScript</code> 下载和执行，从而提高了首屏渲染速度，SEO也更为友好。</p><p>与之相对应的客户端渲染（Client-Side Rendering，简称 CSR）是在客户端下载和执行 <code>JavaScript</code>，然后通过执行 <code>JavaScript</code> 动态生成页面。</p><h2 id="ssr-与-csr-的区别" tabindex="-1">SSR 与 CSR 的区别 <a class="header-anchor" href="#ssr-与-csr-的区别" aria-label="Permalink to &quot;SSR 与 CSR 的区别&quot;">​</a></h2><h3 id="渲染时机" tabindex="-1">渲染时机 <a class="header-anchor" href="#渲染时机" aria-label="Permalink to &quot;渲染时机&quot;">​</a></h3><ul><li>SSR：在服务端生成完整的HTML，浏览器拿到直接渲染。</li><li>CSR：浏览器只拿到一个空的HTML，通过执行 <code>JavaScript</code> 动态生成页面。</li></ul><h3 id="首屏加载速度" tabindex="-1">首屏加载速度 <a class="header-anchor" href="#首屏加载速度" aria-label="Permalink to &quot;首屏加载速度&quot;">​</a></h3><ul><li>SSR：由于浏览器拿到的是完整的html，所以首屏加载速度更快。</li><li>CSR：需要等待 <code>JavaScript</code> 下载和执行，首屏加载速度较慢。</li></ul><h3 id="seo-友好性" tabindex="-1">SEO 友好性 <a class="header-anchor" href="#seo-友好性" aria-label="Permalink to &quot;SEO 友好性&quot;">​</a></h3><ul><li>SSR：由于浏览器拿到的是完整的html，所以搜索引擎爬虫可以抓取到渲染后的内容，SEO友好。</li><li>CSR：由于浏览器拿到的是空的HTML，搜索引擎爬虫可能只能抓取到空的HTML，SEO不友好。</li></ul><h2 id="ssr-的优势和挑战" tabindex="-1">SSR 的优势和挑战 <a class="header-anchor" href="#ssr-的优势和挑战" aria-label="Permalink to &quot;SSR 的优势和挑战&quot;">​</a></h2><p>优势：</p><ol><li>首屏渲染速度快，用户体验好。</li><li>SEO 友好，搜索引擎爬虫可以抓取到渲染后的内容，提高网站排名。</li><li>共享链接的显示预览：在社交媒体上分享链接时，能够正确显示预览信息。</li></ol><p>挑战：</p><ol><li>开发复杂度增加：需要处理服务端和客户端的代码，项目打包和部署都更为麻烦，开发成本也更高。</li><li>性能开销：需要处理服务端渲染的性能开销，如服务器负载、缓存策略等。</li><li>服务器资源：需要更多的服务器资源来处理渲染任务，特别是对于高并发场景。</li><li>状态管理复杂：需要在服务器和客户端之间同步状态，防止数据不一致。</li></ol><h2 id="vue的渲染机制" tabindex="-1">vue的渲染机制 <a class="header-anchor" href="#vue的渲染机制" aria-label="Permalink to &quot;vue的渲染机制&quot;">​</a></h2><p>vue应用的渲染过程如下：</p><ol><li>初始化：通过请求拿到html后，包含 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 根元素和引入的 <code>JavaScript</code> 文件。</li><li>解析：下载并执行 <code>JavaScript</code> 文件，初始化 Vue 实例。</li><li>渲染：Vue 根据模板和数据，生成虚拟 DOM，并渲染成真实 DOM。</li></ol><h2 id="vue-spa的问题" tabindex="-1">vue spa的问题 <a class="header-anchor" href="#vue-spa的问题" aria-label="Permalink to &quot;vue spa的问题&quot;">​</a></h2><ol><li>首屏渲染速度：当应用一旦庞大后，下载和执行 <code>JavaScript</code> 的时间会很长，导致白屏时间过长，影响用户体验。</li><li>SEO：搜索引擎爬虫可能无法爬取 SPA 页面的内容，因为它们不会等待 <code>JavaScript</code> 的执行，只能获取到只带有``<div id="app"></div>`的空 HTML 页面，抓取不到渲染后具体的 DOM 元素。</li><li>社交媒体预览：在社交媒体上分享链接时，无法正确显示预览信息。</li></ol><h2 id="vue-ssr-核心原理" tabindex="-1">vue ssr 核心原理 <a class="header-anchor" href="#vue-ssr-核心原理" aria-label="Permalink to &quot;vue ssr 核心原理&quot;">​</a></h2><p><code>Vue SSR</code> 的核心是将 Vue 组件在服务器端渲染成 HTML 字符串，然后将这个 HTML 字符串发送到客户端，客户端拿到 HTML 后，再通过 vue.js 客户端激活成可交互的应用。</p><h2 id="面试题" tabindex="-1">面试题 <a class="header-anchor" href="#面试题" aria-label="Permalink to &quot;面试题&quot;">​</a></h2><h3 id="说说-vue3-服务端渲染-ssr-的原理-以及它与客户端渲染-csr-的区别" tabindex="-1">说说 Vue3 服务端渲染（SSR）的原理，以及它与客户端渲染（CSR）的区别？ <a class="header-anchor" href="#说说-vue3-服务端渲染-ssr-的原理-以及它与客户端渲染-csr-的区别" aria-label="Permalink to &quot;说说 Vue3 服务端渲染（SSR）的原理，以及它与客户端渲染（CSR）的区别？&quot;">​</a></h3><p>Vue3 服务端渲染（SSR）的原理是将 Vue 组件在服务器端渲染成 HTML 字符串，然后将这个 HTML 字符串发送到客户端，客户端拿到 HTML 后直接渲染，而客户端渲染则拿到的是一个空的 html，需要通过加载和执行 JavaScript 文件，动态生成HTML。</p><p>在SSR中，客户端访问页面时，服务端会根据对应的路由，渲染出对应的HTML，这会提升首屏加载速度和 SEO 性能，客户端拿到 HTML 后，通过 vue.js 的 <code>hydrate</code> 进行“激活”，使其变成一个可交互的 Vue 应用。</p><p>两者的主要区别在于：</p><ul><li>SEO： SSR 比 CSR 更有利于搜索引擎爬取。</li><li>性能：SSR 的首屏加载速度更快，但会增加服务器负载，需要更多的服务器资源和成本。CSR 依赖浏览器的计算能力，首屏加载速度较慢，但不需要额外的服务器资源。</li></ul><p>客户端激活内容：</p><ol><li>DOM 匹配与关联</li></ol><ul><li>将虚拟 DOM 与服务器渲染的 DOM 结构进行匹配</li><li>检查客户端生成的虚拟 DOM 是否与服务器渲染的 HTML 结构一致</li><li>如果发现不匹配，会退出混合模式并重新渲染整个应用</li></ul><ol><li>事件处理绑定</li></ol><ul><li>为已有的 DOM 元素添加事件监听器</li><li>使静态页面变为可交互的</li></ul><ol><li>数据响应式初始化</li></ol><ul><li>初始化 Vue 实例的响应式系统</li><li>将服务器注入的状态(如 Vuex store 状态)同步到客户端</li></ul><ol><li>组件实例化</li></ol><ul><li>为每个服务器渲染的组件创建对应的 Vue 实例</li><li>但不会重新创建 DOM 元素，而是复用现有 DOM</li></ul><ol><li>内部状态恢复</li></ol><ul><li>恢复组件的内部状态(如 data、computed 等)</li><li>确保客户端和服务器端的状态一致</li></ul><h3 id="vue-ssr-中如何解决首屏数据获取问题" tabindex="-1">Vue SSR 中如何解决首屏数据获取问题？ <a class="header-anchor" href="#vue-ssr-中如何解决首屏数据获取问题" aria-label="Permalink to &quot;Vue SSR 中如何解决首屏数据获取问题？&quot;">​</a></h3><p>在 Vue SSR 中，首屏数据通常需要再服务端中完成，常用的方法在组件中定义一个 <code>asyncData</code> 函数，在组件渲染之前，先调用 <code>asyncData</code> 获取数据，然后将数据注入到组件中，再进行渲染。</p><p>具体步骤为：</p><ol><li>在服务器端，在SSR渲染函数中，先调用组件的 <code>asyncData</code> 方法获取数据，再将数据注入到 Vue 组件的 props 中。</li><li>在客户端，Vue 会利用 <code>hydrate</code> 方法进行激活，接管服务端生成的 html，客户端还会将服务端预取的数据作为初始状态传递，避免重复请求。</li></ol><p>数据预取的关键在于服务端需要等待数据加载完毕再渲染页面，以保证给客户端的 HTML 包含实际的数据。</p><blockquote><p>服务端渲染的数据请求会在服务端完成，这样做的好处一个是请求速度快（内网请求、服务器的网络比客户端稳定），还一个好处是数据安全，因为数据请求是在服务端完成的，接口不会暴露给用户，接口数据也不会被随意更改。</p></blockquote><h3 id="如何在-vue-ssr-项目中处理路由和同步状态问题" tabindex="-1">如何在 Vue SSR 项目中处理路由和同步状态问题？ <a class="header-anchor" href="#如何在-vue-ssr-项目中处理路由和同步状态问题" aria-label="Permalink to &quot;如何在 Vue SSR 项目中处理路由和同步状态问题？&quot;">​</a></h3><p>在 Vue SSR 项目中，为了保证服务器和客户端渲染的结果一致，需要处理路由和状态同步问题，可以通过以下方式解决：</p><ol><li>路由同步：在服务器端根据请求 URL 手动调用 <code>router.push</code> 切换到正确的页面，然后通过 <code>router.isReady()</code> 等待所有异步组件加载完成后，再进行服务端渲染，客户端则会根据当前的 URL 初始化路由。</li><li>状态同步：在服务器端渲染时，将 Vuex/Pinia store 的状态通过 JSON 序列化的方式注入到 HTML 中，然后在客户端激活时，将 HTML 中的状态同步到 Vuex/pinia store 中，确保客户端和服务器端的状态一致，同时客户端也不需要再次请求数据。</li></ol>',48)])])}const p=l(r,[["render",t]]);export{n as __pageData,p as default};
