import{_ as e,c as o,o as l,ae as i}from"./chunks/framework.7E1nAy7n.js";const u=JSON.parse('{"title":"Node简介","description":"","frontmatter":{},"headers":[],"relativePath":"collect/node/001.md","filePath":"collect/node/001.md"}'),d={name:"collect/node/001.md"};function t(r,a,n,c,s,h){return l(),o("div",null,[...a[0]||(a[0]=[i('<h1 id="node简介" tabindex="-1">Node简介 <a class="header-anchor" href="#node简介" aria-label="Permalink to &quot;Node简介&quot;">​</a></h1><h2 id="nodejs解决了什么问题" tabindex="-1">Nodejs解决了什么问题？ <a class="header-anchor" href="#nodejs解决了什么问题" aria-label="Permalink to &quot;Nodejs解决了什么问题？&quot;">​</a></h2><ol><li>硬件成本问题：在<code>Java</code>、<code>PHP</code>、<code>.NET</code>等服务端语言中，它们会对每一个请求创建一个线程，每个线程要消耗 2MB 的内存，服务器的硬件成本会随着并发量的增加而增加，</li><li>资源共享问题：一个用户的不同请求，会被不同的服务器处理，所以需要在服务器之间共享资源。</li></ol><p>Nodejs修改了客户端和服务器的连接方式，它不会为每个请求创建一个线程，而是将它转化为一个内部处理的事件，因此，它可以处理成千上万的并发请求，而系统资源消耗却很低。</p><h2 id="为什么选择javascript成为node的实现语言" tabindex="-1">为什么选择JavaScript成为Node的实现语言？ <a class="header-anchor" href="#为什么选择javascript成为node的实现语言" aria-label="Permalink to &quot;为什么选择JavaScript成为Node的实现语言？&quot;">​</a></h2><p>Node的作者Ryan Dahl是一名资深的C/C++程序员，设计高性能服务器是它工作内容的重点，而设计高性能服务器有两个要点：一个是<strong>事件驱动</strong>，另一个是<strong>非阻塞I/O</strong>，Ryan Dahl对一些语言进行了评估：</p><ul><li>C：C的开发门槛高，不会有太多的开发者能将它用于日常的业务开发</li><li>Haskell: Ryan Dahl觉得自己还不足够玩转它</li><li>Lua：Lua自身已经有很多的阻塞I/O库，在这基础上构建非阻塞I/O库很难有市场</li><li>Ruby: Ruby的虚拟机性能不好</li></ul><p>选择JavaScript的原因：</p><ol><li>高性能：Chrome的V8在第二次浏览器大战中性能第一，并且是基于BSD许可证发布的。</li><li>符合时间驱动：JavaScript在浏览器中有许多的事件驱动。</li><li>没有历史包袱：虽然服务端JavaScript存在了很多年，但后端部分一直没有市场。</li></ol><h2 id="node的特点" tabindex="-1">Node的特点 <a class="header-anchor" href="#node的特点" aria-label="Permalink to &quot;Node的特点&quot;">​</a></h2><ol><li>异步I/O</li><li>事件和回调函数</li><li>单线程</li></ol><p>单线程的好处：</p><ul><li>不用在意状态的同步问题，没有死锁。</li><li>没有线程上下文切换的开销。</li></ul><p>单线程的缺点：</p><ul><li>无法利用多核CPU</li><li>一旦出现错误会引起整个应用退出，对应用的健壮性要求高</li><li>大量计算占用CPU导致无法继续调用异步I/O 对于大量计算的场景： 浏览器：可以使用Web Workers。Web Workers能够创建工作线程来进行计算，以解决JavaScript大计算阻塞UI渲染的问题 Node：child_process</li></ul><ol start="4"><li>跨平台</li></ol><p>在Node架构层面，在操作系统与Node上层模块系统之间构建了一层平台层架构libuv，实现Windows和*nix平台的兼容。</p><h2 id="node的应用场景" tabindex="-1">Node的应用场景 <a class="header-anchor" href="#node的应用场景" aria-label="Permalink to &quot;Node的应用场景&quot;">​</a></h2><ul><li>I/O密集型</li><li>分布式应用</li></ul><h2 id="node-vs-java" tabindex="-1">Node vs Java <a class="header-anchor" href="#node-vs-java" aria-label="Permalink to &quot;Node vs Java&quot;">​</a></h2><p><code>Java</code>的特点是静态的、面向对象的语言，优点是稳定性、安全性和跨平台性，缺点是运行速度慢、开发效率低、部署复杂。</p><p><code>Node</code>的特点是异步的、事件驱动的、单线程的，优点是高性能、高并发、开发效率高，缺点是稳定性差、不适合CPU密集型应用。</p>',22)])])}const N=e(d,[["render",t]]);export{u as __pageData,N as default};
