import{_ as a,c as r,o,ae as l}from"./chunks/framework.BAYqcHKv.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/performance/ssr.md","filePath":"collect/performance/ssr.md"}'),t={name:"collect/performance/ssr.md"};function i(c,e,d,s,n,u){return o(),r("div",null,e[0]||(e[0]=[l('<h2 id="vue-ssr-项目改造注意点" tabindex="-1">vue ssr 项目改造注意点 <a class="header-anchor" href="#vue-ssr-项目改造注意点" aria-label="Permalink to &quot;vue ssr 项目改造注意点&quot;">​</a></h2><ul><li>vue生命周期钩子只有<code>beforeCreate</code>和<code>created</code>能用</li><li>避免在 <code>beforeCreate</code> 和 <code>created</code> 生命周期时产生全局副作用的代码，比如你写了一个setInterval，客户端会在<code>beforeDestroy</code>或者<code>destroyed</code>中销毁，而服务端渲染中就没法销毁了，所以这种副作用的代码需要放在<code>beforeMount</code>或者<code>mounted</code>中。</li></ul><h2 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h2><ul><li>使用无全局 window/document 的依赖 减少复杂度高的运算，避免 O(n ^2)</li></ul><h2 id="优化策略" tabindex="-1">优化策略 <a class="header-anchor" href="#优化策略" aria-label="Permalink to &quot;优化策略&quot;">​</a></h2><p>QPS（Query Per Second）也就是每秒的请求数，你的项目QPS是多少，如何提高吞吐？</p><p>SSR的耗时主要是以下两个方面：</p><ul><li>CPU 计算：运行 JS，渲染出静态的 DOM 结构 <ul><li>优化和改进算法，我们用的核心算法都在方法内部，比如<code>vue-server-renderer</code>、<code>vite</code>，要选择尽可以快的生成方案</li><li>精简首屏的DOM结构和数据，减少包大小</li><li>业务代码时间复杂度比较高，也可以优化</li></ul></li><li>网络 IO：获取首屏所需接口数据 <ul><li>使用内网请求接口</li><li>减少网络包体积，和后端协商，只返回必须的字段，或者后端某些耗时的字段上缓存</li><li>缓存（真的需要缓存么？缓存利用率，考虑用户网络，不需要做组件这种细粒度的缓存，侵入业务代码导致可维护性下降）</li></ul></li></ul><h2 id="降级策略" tabindex="-1">降级策略 <a class="header-anchor" href="#降级策略" aria-label="Permalink to &quot;降级策略&quot;">​</a></h2><ul><li>超过一定阈值，降级成CSR，也就是返回静态资源</li><li>网络抖动导致服务端某些数据拉取失败，要在客户端保证用户能看到全的数据</li></ul><h2 id="日志与告警" tabindex="-1">日志与告警 <a class="header-anchor" href="#日志与告警" aria-label="Permalink to &quot;日志与告警&quot;">​</a></h2><p>可观测，可追踪</p>',12)]))}const f=a(t,[["render",i]]);export{_ as __pageData,f as default};
