import{_ as l,c,o,ae as a}from"./chunks/framework.DE6vaMEz.js";const s=JSON.parse('{"title":"003 webpack编译流程","description":"","frontmatter":{"title":"003 webpack编译流程","date":"2021-08-09T00:00:00.000Z","categories":["Webpack"],"tags":["Webpack"],"sidebar":"auto"},"headers":[],"relativePath":"collect/engineer/webpack/003.md","filePath":"collect/engineer/webpack/003.md"}'),t={name:"collect/engineer/webpack/003.md"};function i(d,e,n,r,p,u){return o(),c("div",null,e[0]||(e[0]=[a('<p>webpack的编译流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和Shell语句中读取并合并参数，得出最终的配置对象；</li><li>开始编译：用上一步得到的参数初始化<code>Compiler</code>对象，加载所有配置的插件，执行对象的<code>run</code>方法开始执行编译；</li><li>确定入口，根据配置中的<code>entry</code>找出所有的入口文件；</li><li>编译模块：从入口模块出发，调用所有配置的<code>Loader</code>对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用<code>Loader</code>编译完所有的模块后，得到了每个模块被编译后的最终内容以及它们的依赖关系；</li><li>输出资源：根据入口和模块的依赖关系，组装成一个个包含多个模块的<code>Chunk</code>，再把每个<code>Chunk</code>转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会；</li><li>写入文件：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，webpack会在特定的时间点广播出特定的事件（发布），插件可以去监听自己感兴趣的事件（订阅），等到事件被webpack触发后执行相应的逻辑，比如改变webpack的运行结果。</p><h2 id="module、chunk、bundle的区别" tabindex="-1">module、chunk、bundle的区别 <a class="header-anchor" href="#module、chunk、bundle的区别" aria-label="Permalink to &quot;module、chunk、bundle的区别&quot;">​</a></h2><ul><li>module：各个源码文件，webpack中一切皆模块</li><li>chunk：多模块合并成的，如entry、import()、splitChunk</li><li>bundle：最终的输出文件</li></ul>',5)]))}const _=l(t,[["render",i]]);export{s as __pageData,_ as default};
