import{_ as i,o as a,c as n,ae as l}from"./chunks/framework.h0LyDJ8h.js";const E=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/performance/14.高级进阶：瞒天过海的骨架屏及SSR优化手段.md","filePath":"note/performance/14.高级进阶：瞒天过海的骨架屏及SSR优化手段.md"}'),t={name:"note/performance/14.高级进阶：瞒天过海的骨架屏及SSR优化手段.md"};function p(e,s,h,k,r,o){return a(),n("div",null,[...s[0]||(s[0]=[l(`<h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>骨架屏可以使用户预期到接下来要展示的内容和结构，让用户觉得页面加载快了，而 SSR 则可以让白屏时间大幅缩短。</p><p>具体该怎么实现骨架屏和 SSR 呢？在实际工作中如何落地操作呢？</p><h2 id="使用骨架屏方案优化页面性能" tabindex="-1">使用骨架屏方案优化页面性能 <a class="header-anchor" href="#使用骨架屏方案优化页面性能" aria-label="Permalink to &quot;使用骨架屏方案优化页面性能&quot;">​</a></h2><p>为了让骨架屏内容和页面结构更类似，提升用户体验，我们一般采用的是图片骨架屏。</p><h2 id="图片骨架屏的实现" tabindex="-1">图片骨架屏的实现 <a class="header-anchor" href="#图片骨架屏的实现" aria-label="Permalink to &quot;图片骨架屏的实现&quot;">​</a></h2><p>设计师针对这个页面制作一张离线包图片，在 Webview 启动时，客户端把这张图片覆盖在页面上，页面开始进入请求资源的流程，当页面 webview 加载完成或者前端页面通知客户端加载完成时，客户端通过渐变动画隐藏这张图片，将准备好对的页面展现给用户。</p><p>实现步骤：</p><ol><li>先让 UI 设计师设计一张对当前页面对应离线包的图片作为骨架屏展示图片</li><li>在业务需求开发过程中，前端工程师拿到图后，把这张图片上传到 CDN 上面</li><li>在客户端代码增加启动时读取图片骨架屏配置文件，配置的大致逻辑是，先传入设备分辨率，比如 400x500。</li></ol><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传入设备分辨率 ratioWidth: 400, ratioHeight: 500</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;code&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0 代表请求陈工，-1 代表图片骨架屏功能关闭</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;m.58.com/enjoy-given/eg/index.html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 页面 url</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;rege&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;#/content/index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;routes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;#/content/index&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          &quot;downloadUrl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://m.58.com/pic.png?400*500&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 骨架屏图片地址</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          &quot;imgName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;pic.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">          &quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;10001&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;msg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>当客户打开url时，客户端对url进行解析，取得对应的 host 和 pathName，然后将两个数据分别与 data 和 routes中的数据作比较，如果都匹配上，说明要展示骨架屏。</p><p>注意点：</p><ol><li>注意区分首次使用和二次使用：</li></ol><ul><li>首次使用的话，客户端遍历上述配置文件，下载数据中对应图片即可</li><li>二次使用时，需要那当前配置文件对比之前的配置文件，如果图片名称不同，需要下载新的图片</li></ul><ol start="2"><li>需要客户独胆在内存中建立图片，以加快图片骨架屏的加载速度</li><li>图片骨架屏展示过程中会出现拉伸问题。这时因为分辨率不同造成的，我们可以让 App 在获取配置文件时，加上当前页面的分辨率，这样接口会根据分辨率返回最合适的图片。</li></ol><h2 id="使用及注意事项" tabindex="-1">使用及注意事项 <a class="header-anchor" href="#使用及注意事项" aria-label="Permalink to &quot;使用及注意事项&quot;">​</a></h2><p>骨架屏方案，非常适合资源加载时间长的页面。比如列表页的首屏内容有很多个数据接口、筛选项、精选数据、列表数据等，这时候一定要用骨架屏，而对于一些 SSR 页面，因为白屏阶段比较短，可用可不用。</p><p>骨架屏使用起来比较简单，UI 对应出一个骨架屏的图片，然后上传到 CDN，并给出页面路径和文件路径，生成配置文件给客户端，客户端根据配置加载骨架屏即可。</p><p>骨架屏中的内容结构，应该只是首屏对的内容结构，不是整个页面的内容结构，反之会造成图片骨架屏体积过大，加载骨架屏时间过长的问题。</p><p>骨架屏的问题，比如加载异常时没有提示，或者展示时间过长，因为他不会影响白屏时间，我们很难发现，所以骨架屏什么时候展示和什么时候销毁，客户端要以日志形式记录下来，上传到性能监控平台，这样定期去看一下日志，则可以发现问题。</p><h2 id="使用-ssr-方案优化页面性能" tabindex="-1">使用 SSR 方案优化页面性能 <a class="header-anchor" href="#使用-ssr-方案优化页面性能" aria-label="Permalink to &quot;使用 SSR 方案优化页面性能&quot;">​</a></h2><p>一个 Web页面的渲染主要由客户端或者浏览器端来完成。大概过程是，客户端从服务端请求到 index.html，然后加载脚本文件，web应用通过 ajax 请求到页面数据，并把对应对的数据填充到模板中，最终形成完成的页面来呈现给用户。</p><p>SSR则把数据请求放在了服务端，服务端收到返回结果时，把数据填充到模板形成完整的页面，由服务端把拼接完成的完整页面返回给客户端。</p><h2 id="ssr-的实现及使用" tabindex="-1">SSR 的实现及使用 <a class="header-anchor" href="#ssr-的实现及使用" aria-label="Permalink to &quot;SSR 的实现及使用&quot;">​</a></h2><p>手机业务迭代开发速度比较快，我们希望将 SSR 开发的一些配置能够封装起来，让前端工程师介入成本降低。</p><p>Nuxt.js 是一款基于 Vue 的SSR 开源框架，使用 webpack 和 Node.js 进行封装，其中预设了开发服务端渲染应用所需要的各种配置。</p><h2 id="白屏时间-100ms-的ssr优化" tabindex="-1">白屏时间 100ms 的SSR优化 <a class="header-anchor" href="#白屏时间-100ms-的ssr优化" aria-label="Permalink to &quot;白屏时间 100ms 的SSR优化&quot;">​</a></h2><ul><li><p>利用服务端的性能优势，尽量在服务端完成资源加载、首屏切分等工作。</p></li><li><p>利用服务端统计缓存机制，对数据接口、页面和组件做缓存。</p></li><li><p>服务端渲染的最大优势，就是后端服务性能要远高于手机，所以请求数据接口和渲染时，耗时会更短。</p></li><li><p>服务端缓存与客户端最大不同是，服务端属于统一公用，也就是说，只要某一个用户访问过一次，后续所有用户的访问都可以使用这份缓存。</p></li><li><p>LRU 属于页面级缓存，对于数据统一性页面，利用 LRU-Cache 可以缓存当前请求的数据资源。</p></li><li><p>使用 Redis 可以对跨页面的数据接口进行缓存，将整体渲染时间再减少100ms。因为SSR应用程序部署在多服务、多进程下，该进程下的缓存并不是共享对的，这就造成缓存命中效率低下，而使用 redis 可以解决这个问题，进而实现更好的跨页面数据缓存。</p></li></ul><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>以上就是骨架屏和SSR性能优化方案。</p><ul><li>SSR需要你对后端只是，尤其是 Node.js 只是有很好的把握，且具备一定的数据接口设计规划和设计能力</li><li>SSR渲染对进行的页面，一些实践还在绑定中，有可能出现操作没反应的情形。</li></ul>`,31)])])}const u=i(t,[["render",p]]);export{E as __pageData,u as default};
