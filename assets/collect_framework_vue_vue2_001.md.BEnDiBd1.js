import{_ as i,c as a,o as e,ae as n}from"./chunks/framework.CqlM4162.js";const l="/blog/assets/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86.CNHFIUb5.png",E=JSON.parse('{"title":"001 Vue2响应式原理","description":"","frontmatter":{"title":"001 Vue2响应式原理","date":"2022-02-17T00:00:00.000Z","categories":["Vue"],"tags":["Vue2.0"],"sidebar":"auto"},"headers":[],"relativePath":"collect/framework/vue/vue2/001.md","filePath":"collect/framework/vue/vue2/001.md"}'),t={name:"collect/framework/vue/vue2/001.md"};function h(p,s,k,d,r,c){return e(),a("div",null,s[0]||(s[0]=[n('<p><img src="'+l+`" alt="图片加载失败"></p><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>我们都知道，<code>Vue</code>的特点之一就是<code>数据驱动视图</code>，就是说数据发生变化之后，视图会进行更新，这背后的原理就是vue的响应式系统。应用在运行时需要不断地进行渲染，而响应式系统的任务就是<code>让视图随着状态的变化而变化</code>。接下来探索一下Vue2.0的响应式原理。</p><h2 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文" aria-label="Permalink to &quot;正文&quot;">​</a></h2><h3 id="_1-如何监听对象变化" tabindex="-1">1.如何监听对象变化？ <a class="header-anchor" href="#_1-如何监听对象变化" aria-label="Permalink to &quot;1.如何监听对象变化？&quot;">​</a></h3><p>对于JavaScript对象来说，如何侦测一个对象的变化？</p><p>这主要有两种方式，一个是使用<code>Object.defineProperty</code>，另一个是ES6提供的<code>Proxy</code>。而<code>Proxy</code>在浏览器的支持度并不理想，所以vue2.0当时实现的时候采用了<code>Object.defineProperty</code>，重写属性的代码如下:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, key, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        configurable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        enumerable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (newVal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们定义一个<code>defineReactive</code>函数，用<code>闭包</code>保留一个<code>val</code>，当页面取值的时候，会走到<code>get</code>函数，返回<code>val</code>，数据改变会触发<code>set</code>函数，修改<code>val</code>。</p><h3 id="_2-如何监听数组变化" tabindex="-1">2.如何监听数组变化？ <a class="header-anchor" href="#_2-如何监听数组变化" aria-label="Permalink to &quot;2.如何监听数组变化？&quot;">​</a></h3><p>我们都知道，数组其实也是对象，同样可以用<code>Object.defineProperty</code>劫持数组的每一项，但如果数组有100万项，那就要调用<code>Object.defineProperty</code>一百万次，这样的话性能太低了。鉴于平时我们操作数组大都是采用数组提供的原生方法，于是Vue对数组重写原型链，在调用7个能改变自身的原生方法(<code>push</code>，<code>pop</code>，<code>shift</code>，<code>unshift</code>，<code>splice</code>，<code>sort</code>，<code>reverse</code>)时，通知页面进行刷新，具体实现过程如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 先拿到数组的原型</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> oldArrayProtoMethods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用Object.create创建一个以oldArrayProtoMethods为原型的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arrayMethods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldArrayProtoMethods)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> methods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;push&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;pop&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;shift&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;unshift&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;sort&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;reverse&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;splice&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">methods.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">method</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 给arrayMethods定义7个方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arrayMethods[method] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 先找到数组对应的原生方法进行调用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldArrayProtoMethods[method].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, args)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 声明inserted，用来保存数组新增的数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inserted</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // __ob__是Observer类实例的一个属性，data中的每个对象都是一个Observer类的实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ob</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.__ob__</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(method) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;push&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;unshift&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                inserted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            case</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;splice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                inserted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> args.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                break</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 比如有新增的数据，新增数据也要被定义为响应式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inserted) ob.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observeArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(inserted)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 通知页面更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ob.dep.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">notify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> result</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h3 id="_3-如何收集依赖以及依赖更新" tabindex="-1">3.如何收集依赖以及依赖更新？ <a class="header-anchor" href="#_3-如何收集依赖以及依赖更新" aria-label="Permalink to &quot;3.如何收集依赖以及依赖更新？&quot;">​</a></h3><p>在Vue的响应式系统中，有三个核心类，它们分别是</p><ol><li><code>Observer</code>：我们data中的每个对象会返回一个Observer类的实例；</li><li><code>Dep</code>：对象中每个属性会创建一个Dep，另外每一个对象还会单独创建一个Dep；</li><li><code>Watcher</code>：也就是<code>依赖</code>，Watcher有三种</li></ol><ul><li><code>渲染Watcher</code>：Vue会为每个组件会创建一个渲染Watcher（函数式组件除外）；</li><li><code>用户Watcher</code>：我们自己在watch对象中写的watch；</li><li><code>计算属性Watcher</code>：我们自己定义的计算属性，最终也是靠Watcher来实现的；</li></ul><p>步骤：</p><ol><li>创建渲染<code>Watcher</code>，默认会调用this.get方法</li><li>将当前渲染<code>Watcher</code>保存在Dep.target上</li><li>调用vm._render，会去data上取值，走到<code>get</code>方法，并将当前属性的<code>Dep</code>和Dep.target的渲染Watcher进行关联，</li><li>当数据更新时，会走到数据的<code>set</code>方法，<code>set</code>方法中会调用<code>Dep.notify</code>方法，找到当前Dep依赖的Watcher，调用watcher.update方法</li><li>重新调用vm._render进行取值。</li></ol><h3 id="_4-整体流程" tabindex="-1">4.整体流程 <a class="header-anchor" href="#_4-整体流程" aria-label="Permalink to &quot;4.整体流程&quot;">​</a></h3><ol><li>遍历data中的数据，如果是<code>obj</code>就创建一个<code>Observer</code>实例，<code>new Observer(obj)</code></li><li>给当前对象增加一个<code>Dep实例</code>，并当前实例保存在<code>__ob__</code>属性上，<code>this.__ob__ = this</code>，表示当前属性已经被代理</li><li>判断传入对象是不是数组，如果是数组则重写原型链，拦截<code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code>,<code>splice</code>,<code>sort</code>,<code>reverse</code>七个方法，并调用observeArray遍历数组，将数组的每一项的对象定义为响应式</li><li>如果不是数组则是对象，则调用<code>walk</code>方法循环对象，对每个属性调用<code>defineReactive</code>方法，在<code>defineReactive</code>方法中会为当前属性创建一个<code>Dep</code>实例，并调用<code>Object.defineProperty</code>进行重新定义<code>get</code></li><li>创建<code>渲染Watcher</code>进行页面渲染，将当前Watcher放到<code>Dep.target</code>上，<code>Dep.target = [Watcher]</code></li><li>调用<code>vm._render</code>，会取值，走到<code>get</code>方法，将<code>Dep</code>和<code>target</code>关联，再调用<code>vm._update</code>将虚拟节点创建为真实节点并渲染到页面上</li><li>数据更新，走到<code>set</code>方法，调用<code>Dep.notify</code>方法，找到当前<code>Dep</code>收集的<code>Watcher</code>，调用<code>Watcher.update</code></li><li>重新调用<code>vm._render</code>,再调用<code>vm._update</code>将虚拟节点创建为真实节点并渲染到页面上</li></ol><h3 id="_5-object-defineproperty的缺点" tabindex="-1">5.Object.defineProperty的缺点 <a class="header-anchor" href="#_5-object-defineproperty的缺点" aria-label="Permalink to &quot;5.Object.defineProperty的缺点&quot;">​</a></h3><ol><li>无法监听新增属性和删除属性的变化</li><li>监测数组的索引性能太低，故而直接通过数组索引改值无法触发响应式</li><li>初始化时需要一次性递归调用，性能较差</li></ol><h3 id="_6-proxy和object-defineproperty对比" tabindex="-1">6.proxy和Object.defineProperty对比 <a class="header-anchor" href="#_6-proxy和object-defineproperty对比" aria-label="Permalink to &quot;6.proxy和Object.defineProperty对比&quot;">​</a></h3><ul><li><code>Vue3.0</code>的proxy：代理<code>对象</code>，能监听到对象新增属性和删除属性，以及数组的索引和length变化，可以进行懒递归，性能较好，</li><li><code>Vue2.0</code>的Object.defineProperty: 代理<code>属性</code>，只能能监听到对象已有的属性，监听数组索引性能消耗大，不能进行懒递归，性能较差。</li></ul>`,24)]))}const y=i(t,[["render",h]]);export{E as __pageData,y as default};
