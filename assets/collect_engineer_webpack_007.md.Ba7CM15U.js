import{_ as l,c as a,o,ae as i}from"./chunks/framework.7E1nAy7n.js";const u=JSON.parse('{"title":"007 webpack常见问题","description":"","frontmatter":{"title":"007 webpack常见问题","date":"2021-08-18T00:00:00.000Z","categories":["Webpack"],"tags":["Webpack"],"sidebar":"auto"},"headers":[],"relativePath":"collect/engineer/webpack/007.md","filePath":"collect/engineer/webpack/007.md"}'),c={name:"collect/engineer/webpack/007.md"};function r(d,e,t,p,s,n){return o(),a("div",null,[...e[0]||(e[0]=[i('<h2 id="前端为何要进行打包和构建" tabindex="-1">前端为何要进行打包和构建？ <a class="header-anchor" href="#前端为何要进行打包和构建" aria-label="Permalink to &quot;前端为何要进行打包和构建？&quot;">​</a></h2><p>代码层面：</p><ul><li>体积更小（Tree-Shaking、压缩、合并），加载更快</li><li>编译高级语言或语法（TS，ES6+，模块化，scss）</li><li>兼容性和错误检查（Polyfill、postcss、eslint）</li></ul><p>研发流程层面：</p><ul><li>统一、高效的开发环境</li><li>统一的构建流程和产出标准</li><li>集成公司构建规范（提测、上线等）</li></ul><h2 id="loader和plugin的区别" tabindex="-1">Loader和Plugin的区别 <a class="header-anchor" href="#loader和plugin的区别" aria-label="Permalink to &quot;Loader和Plugin的区别&quot;">​</a></h2><ul><li>loader模块转换器，如less-&gt;css</li><li>plugin扩展插件，如HtmlWebpackPlugin</li></ul><h2 id="常见的loader和plugin有哪些" tabindex="-1">常见的Loader和Plugin有哪些 <a class="header-anchor" href="#常见的loader和plugin有哪些" aria-label="Permalink to &quot;常见的Loader和Plugin有哪些&quot;">​</a></h2><ul><li><a href="https://webpackjs.com/loaders" target="_blank" rel="noreferrer">loaders</a></li><li><a href="https://webpackjs.com/plugins" target="_blank" rel="noreferrer">plugins</a></li></ul><h2 id="babel和webpack的区别" tabindex="-1">babel和webpack的区别 <a class="header-anchor" href="#babel和webpack的区别" aria-label="Permalink to &quot;babel和webpack的区别&quot;">​</a></h2><ul><li>babel-JS新语法编译工具，不关心模块化</li><li>webpack-打包构建工具，是多个loader、plugin的集合</li></ul><h2 id="babel-polyfill和babel-runtime的区别" tabindex="-1">babel-polyfill和babel-runtime的区别 <a class="header-anchor" href="#babel-polyfill和babel-runtime的区别" aria-label="Permalink to &quot;babel-polyfill和babel-runtime的区别&quot;">​</a></h2><ul><li>babel-polyfill会污染全局</li><li>babel-runtime不会污染全局</li><li>产出第三方lib要用babel-runtime</li></ul><h2 id="webpack如何实现懒加载" tabindex="-1">webpack如何实现懒加载 <a class="header-anchor" href="#webpack如何实现懒加载" aria-label="Permalink to &quot;webpack如何实现懒加载&quot;">​</a></h2><ul><li>import()</li><li>结合Vue、React异步组件</li><li>结合Vue-router、React-router异步加载路由</li></ul><h2 id="为何proxy不能被polyfill" tabindex="-1">为何Proxy不能被Polyfill <a class="header-anchor" href="#为何proxy不能被polyfill" aria-label="Permalink to &quot;为何Proxy不能被Polyfill&quot;">​</a></h2><ul><li>如Class可以用function模拟</li><li>如Promise可以用callback模拟</li><li>但Proxy的功能用Object.defineProperty无法模拟</li></ul><h2 id="npm依赖的分类" tabindex="-1">npm依赖的分类 <a class="header-anchor" href="#npm依赖的分类" aria-label="Permalink to &quot;npm依赖的分类&quot;">​</a></h2><ul><li>dependencies <ul><li>运行项目业务逻辑需要的第三方库</li><li>npm install &#39;模块名称&#39;的时候都会被解析，下载</li></ul></li><li>devDependencies <ul><li>开发模式工作流下依赖的第三方库</li><li>单元测试，语法转换，lint工具，程序构建，本地开发等等</li></ul></li><li>peerDependencies <ul><li>需要核心依赖库，不能脱离依赖库单独使用</li></ul></li></ul><h2 id="webpack热更新原理" tabindex="-1">webpack热更新原理 <a class="header-anchor" href="#webpack热更新原理" aria-label="Permalink to &quot;webpack热更新原理&quot;">​</a></h2><p>webpack热更新又叫热替换（<code>Hot Module Replacement</code>），简称<code>HMR</code>，这个机制能做到不用刷新页面就实现模块的替换。</p><p>核心：webpack + http + websocket + jsonp</p><ol><li>启动一个HTTP服务器，会打包我们的项目，并且让我们可以预览我们产出的文件，默认端口号8080</li><li>还会启动一个<code>websocket</code>双向通信服务器，如果有新的模块发生变更的话，会通过消息的方式通知客户端，让客户端拉取最新代码，并且进行客户端的热更新</li><li>服务器监听 webpack 打包的 done 事件，并发向客户端发送消息 hash 和 ok 消息</li><li>客户端收到<code>hash</code>消息，保存hash值</li><li>客户端收到<code>ok</code>消息，会派发<code>webpackHotUpdate</code>事件</li><li>webpack/hot/dev-server收到<code>webpackHotUpdate</code>事件，会执行<code>hotCheck</code>进行热更新检查，通过ajax拉取<code>[chunkId].[lastHash].hot-update.json</code>，创建script拉取<code>[chunkId].[lastHash].hot-update.js</code>两个补丁包，其中json文件包含更改的代码块，而js文件是最新的模块信息</li><li>js补丁包拉取下来后，会调用<code>webpackHotUpdate[包名]</code>方法，然后会改变<code>modules</code>对象，并删除原来模块的缓存，并通过当前模块 id 找到父模块执行<code>accept</code>回调，重新加载当前模块。</li></ol><h2 id="webpack-import懒加载原理" tabindex="-1">webpack import懒加载原理 <a class="header-anchor" href="#webpack-import懒加载原理" aria-label="Permalink to &quot;webpack import懒加载原理&quot;">​</a></h2><ol><li>调用<code>__webpack_require__.e</code>方法加载模块</li><li>声明一个promises数组，调用<code>__webpack_require__.f.j</code>方法，传入<code>chunkId</code>和<code>promises数组</code>，创建一个promise实例，将<code>[resolve, reject, promise]</code>存入<code>installedChunks</code>中，并把当前的promise实例放入<code>promises数组</code>中，然后返回<code>Promise.all(promises)</code></li><li>调用<code>__webpack_require__.l</code>方法，创建<code>script标签</code>，发送请求加载脚本</li><li>拿到脚本执行<code>webpackJsonpCallback</code>方法，将当前的<code>moreModules</code>合并到<code>__webpack_modules__</code>中，并执行<code>resolve</code>方法让我们创建的promise成功，然后将<code>installedChunks[chunkId]</code>改为0</li><li>promise成功后会执行<code>require</code>方法去加载这个模块，从<code>__webpack_modules__</code>拿到模块定义函数并执行拿到结果，需要注意的是，不管加载的是commonjs模块还是es module模块，最终拿到的结果都会包装成es module。</li></ol>',25)])])}const h=l(c,[["render",r]]);export{u as __pageData,h as default};
