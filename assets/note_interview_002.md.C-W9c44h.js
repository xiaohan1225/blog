import{_ as i,c as o,o as r,j as l,ae as d,a as t,t as n}from"./chunks/framework.BFe6FF_l.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"note/interview/002.md","filePath":"note/interview/002.md"}'),s={name:"note/interview/002.md"};function u(a,e,m,p,h,f){return r(),o("div",null,[e[14]||(e[14]=l("h2",{id:"前言",tabindex:"-1"},[t("前言 "),l("a",{class:"header-anchor",href:"#前言","aria-label":'Permalink to "前言"'},"​")],-1)),l("p",null,[e[0]||(e[0]=t("vue提供了两种编译版本，一种是",-1)),e[1]||(e[1]=l("code",null,"Runtime-Compiler",-1)),e[2]||(e[2]=t("，还有一种是",-1)),e[3]||(e[3]=l("code",null,"Runtime-only",-1)),e[4]||(e[4]=t("，前者会多提供",-1)),e[5]||(e[5]=l("code",null,"compiler",-1)),e[6]||(e[6]=t("功能，也就是支持",-1)),e[7]||(e[7]=l("code",null,"template",-1)),e[8]||(e[8]=t("写法。也就是我们可以在组件对象中写",-1)),l("code",null,"template:<div>"+n(a.a)+"</div>",1),e[9]||(e[9]=t("，然后vue内部会把template转化为",-1)),e[10]||(e[10]=l("code",null,"render函数",-1)),e[11]||(e[11]=t("，这个过程就是",-1)),e[12]||(e[12]=l("code",null,"模板编译",-1)),e[13]||(e[13]=t("。",-1))]),e[15]||(e[15]=d('<h2 id="模板编译" tabindex="-1">模板编译 <a class="header-anchor" href="#模板编译" aria-label="Permalink to &quot;模板编译&quot;">​</a></h2><h3 id="原因" tabindex="-1">原因 <a class="header-anchor" href="#原因" aria-label="Permalink to &quot;原因&quot;">​</a></h3><ul><li>模板不是html，有指令、插值、JS表达式，能实现判断、循环</li><li>html是标签语言，只有JS才能实现判断、循环（图灵完备的，能实现我们日常的业务逻辑，能实现顺序执行、循环和判断）</li><li>因此，模板一定是转换为某种JS代码，即模板编译</li></ul><h3 id="过程" tabindex="-1">过程 <a class="header-anchor" href="#过程" aria-label="Permalink to &quot;过程&quot;">​</a></h3><ul><li>width语法</li><li>vue template complier将模板编译为render函数</li><li>执行render函数生成vnode</li><li>基于vnode再执行patch和diff</li><li>使用vue-loader，会在开发环境下编译模板</li></ul><h2 id="初次渲染" tabindex="-1">初次渲染 <a class="header-anchor" href="#初次渲染" aria-label="Permalink to &quot;初次渲染&quot;">​</a></h2><ul><li>initState数据劫持，添加getter和setter</li><li>挂载时将模板编译成render函数（或在开发环境下用vue-loader完成）</li><li>调用render函数生成vdom，收集依赖</li><li>patch(elm, vnode)渲染到页面上</li></ul><h2 id="更新流程" tabindex="-1">更新流程 <a class="header-anchor" href="#更新流程" aria-label="Permalink to &quot;更新流程&quot;">​</a></h2><ul><li>修改数据，触发setter</li><li>找到依赖它的所有watcher，调用update方法</li><li>重新调用render函数，生成新的vdom</li><li>patch(oldVnode, newVnode) diff 算出最小变更，nextTick 异步渲染批量更新渲染视图（减少啊DOM操作次数，提高性能）</li></ul><h2 id="过程-1" tabindex="-1">过程 <a class="header-anchor" href="#过程-1" aria-label="Permalink to &quot;过程&quot;">​</a></h2><p>vue的模板解析分为三步：</p><ol><li>将template转成ast</li><li>optimization</li><li>转化成render函数</li></ol><h3 id="将template转成ast" tabindex="-1">将template转成ast <a class="header-anchor" href="#将template转成ast" aria-label="Permalink to &quot;将template转成ast&quot;">​</a></h3><p>vue会先拿到<code>template</code>字符串，然后通过内部定义一些正则做的解析，字符串解析一部分就删除一部分，同时用一个<code>栈</code>保证标签的正常闭合。</p><h3 id="optimization" tabindex="-1">optimization <a class="header-anchor" href="#optimization" aria-label="Permalink to &quot;optimization&quot;">​</a></h3><p>这一步的目的是标记<code>静态节点</code>和<code>静态根节点</code>，在diff的时候可以跳过静态节点，提高性能。</p><h3 id="转化成render函数" tabindex="-1">转化成render函数 <a class="header-anchor" href="#转化成render函数" aria-label="Permalink to &quot;转化成render函数&quot;">​</a></h3><p>这一步就是用<code>_c</code>、<code>_v</code>、<code>_l</code>、<code>_s</code>等方法去对ast做一个字符串的拼接，再利用<code>with</code>去组件实例上取值，然后用<code>new Function</code>把它包装成一个函数，调用这个函数就得到组件的<code>虚拟节点</code>。</p>',18))])}const q=i(s,[["render",u]]);export{v as __pageData,q as default};
