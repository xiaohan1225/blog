import{_ as s,c as a,o as l,ae as t}from"./chunks/framework.BFe6FF_l.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"collect/performance/6. 工具实践：性能SDK及上报策略设计.md","filePath":"collect/performance/6. 工具实践：性能SDK及上报策略设计.md"}'),p={name:"collect/performance/6. 工具实践：性能SDK及上报策略设计.md"};function e(n,i,h,r,k,o){return l(),a("div",null,[...i[0]||(i[0]=[t(`<h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>前端开发人员接入性能监控平台过程中文档不全，调试工具匮乏，上报过程中日志量过大。</p><p>完成奥林匹亚项目之后，公司的业务从 PC 端迁移到移动端。</p><p>为了让这些页面接入性能监控平台，通常需要修改性能统计脚本后才可以，同时由于各业务频繁升级脚本性能脚本，测试也变得非常麻烦。</p><p>问题：如何通过设计性能 SDK（Software Development Kit，软件开发工具包），制定合理的上报策略来解决性能指标采集过程中的难题？</p><h2 id="性能-sdk-设计" tabindex="-1">性能 SDK 设计 <a class="header-anchor" href="#性能-sdk-设计" aria-label="Permalink to &quot;性能 SDK 设计&quot;">​</a></h2><p>SDK：是指开发者为特定的软件、平台、操作系统提供对的开发工具集。</p><p>性能 SDK，即为公司各个产品业务提供性能统计的 JS SDK，主要是将性能采集代码和上报策略封装在一起，通过采集首屏、白屏等指标数据，然后上报到性能平台后端进行处理。</p><p>要求：</p><ul><li>简单易用</li><li>运行平稳高效</li></ul><p>包括：</p><ul><li>API 接口</li><li>工程引入</li><li>文档平台</li><li>开发调试工具</li></ul><p>Perf API：</p><ul><li>FMP API <ul><li>calcScore API：首屏采集分数计算</li><li>calcFinallScore API：变化率计算</li><li>fmpImg API：首屏图片时间计算（由于比较独立，可以单独封装成一个 util，供其它模块调用）</li></ul></li><li>FP API：白屏</li><li>BLOCK API：卡顿</li><li>Extension API：后续需要使用的功能，比如加载瀑布流相关的数据，也就是说将首屏时间细分为 DNS、TCP连接等时间，这些数据可以浏览器提供的 Performance API（做兼容性处理，看浏览器支不支持 Performance API） 来获取。</li></ul><h2 id="sdk-接入设计" tabindex="-1">SDK 接入设计 <a class="header-anchor" href="#sdk-接入设计" aria-label="Permalink to &quot;SDK 接入设计&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// npm install @common/Perf -S</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { perfInit } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@common&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">perfInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>或者以 CDK 外部引入的方式：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;https://cdn.jsdelivr.net/common/perf/static/js/1.0.0/perf.min.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  perfInit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>搭建一个简单的性能 SDK 网站，进入站点后，前端工程师可以看到使用文档，包括各种平台下如何接入，接入的示例代码是怎样的，接入性能 SDK 后去哪个 URL 看数据，遇到异常问题时怎么调试等。</p><p>设置性能分析小助手，快速定位和诊断一些基础问题。</p><ul><li>在 SDK 中检测访问页面的 URL 是不是加了调试参数（PERF_DEV_MODEL=PERF_DEV_NODEL）。</li><li>如果访问的页面 URL 加了调试参数，打开页面后就可以看到一个性能分析小助手的圆形图标。</li></ul><p>比如：</p><ul><li>性能 SDK 初始化失败</li><li>采集数据异常</li><li>发送的请求参数正不正确等问题</li></ul><p>如果遇到帮助文档没提及过的问题，可以借助低代码存放对的 Gitlab 平台，让前端工程师通过 issue 的方式提交问题，看到问题后我们及时回复解决。</p><h2 id="sdk-运行设计" tabindex="-1">SDK 运行设计 <a class="header-anchor" href="#sdk-运行设计" aria-label="Permalink to &quot;SDK 运行设计&quot;">​</a></h2><p>兼容性策略就是性能 SDK 可以在各个业务下都可以稳定运行。</p><p>业务场景：</p><ul><li>各类页面：平台型页面、3C 类页面、中后台页面</li><li>一些可视化搭建的平台，如用来搭建天猫双十一会场页，用于交易运行页面的魔方系统</li><li>各个终端：PC端、移动端、小程序等。</li></ul><p>一般不同页面和终端，它们的技术栈也会不同，比如 PC 端使用 Vue，移动端使用 React，小程序使用小程序框架。</p><p>我们可以尽可能用原生 JavaScript 去做性能指标的采集，从而实现跨不同技术栈对的采集。</p><p>小程序可以有自己的采集 API，其它端可以直接用 FMP，根据当前终端类型的不同，去调用个自己性能指标采集 API。</p><p>容错方面怎么做呢？</p><ul><li>如果是性能 SDK 自身的报错，可以通过 try catch 的方式捕获到，然后上报异常监控平台。</li><li>好的自测和 QA 的测试也是性能 SDK 运行平稳的一大保障。</li></ul><blockquote><p>可以根据用户实际的浏览器和机型分布比例，确定 top10% 用户的机型和浏览器类型，然后在每次开发完成并进行代码 review 后，使用这些机型和浏览器类型进行自测。</p></blockquote><h2 id="上报策略设计" tabindex="-1">上报策略设计 <a class="header-anchor" href="#上报策略设计" aria-label="Permalink to &quot;上报策略设计&quot;">​</a></h2><p>上报策略是指在性能指标采集完成后，上报到性能平台所采用的具体策略。比如通过 SDK 上报到性能平台后端，是数据直接上传呢，还是做一些过滤处理，全量数据上传还是抽样，是选择 H5 接口上报，还是通过 native 接口上报？</p><h3 id="日志数据过滤" tabindex="-1">日志数据过滤 <a class="header-anchor" href="#日志数据过滤" aria-label="Permalink to &quot;日志数据过滤&quot;">​</a></h3><p>采集性能指指标之后，最好先对异常数据进行过滤。（打错误日志并上报到错误异常平台）</p><ul><li>第一类是计算错误导致的异常数据。比如负值、非数值 <ul><li>负值的性能指标数据影响很大，它会严重拖低首屏时间，也会把计算逻辑导致负值的问题给掩盖掉。</li><li>首屏时间是非数值数据的时候也非常麻烦，这里使用引号是因为它是字符串类型，在采集过程中计算时，遇到加法时，会出现 “200” + 30 = “20030” 的情况，而不是你预期的 230 的情况。</li></ul></li><li>第二类是合法异常值、极大值、极小值，属于网络断掉或者超时形成的数值。比如 15s 以上的首屏时间。</li></ul><h3 id="数据抽样策略" tabindex="-1">数据抽样策略 <a class="header-anchor" href="#数据抽样策略" aria-label="Permalink to &quot;数据抽样策略&quot;">​</a></h3><p>性能 SDK 上报数据是全量还是抽样，需要根据本身 App 或者网站的日活来确定。日活 10 万以下就没必要抽样了，如果是一款日活千万的 APP，那么就必须进行数据抽样了，如果全量上报会消耗大量用户的流量和请求带宽。像 58 同城，我们做的就是 10% 的抽样率，也就是百万级的数据。</p><p>除了在 SDK 里面设置抽样策略，业界还有通过服务端下发数据抽样率的方式，来动态控制客户端向服务端上报性能数据的量。比如双12运行活动当天，日活用户急增，抽样率由原来的 10% 降低到 5%，可以大大降低运营活动时统计服务器的负载。</p><h3 id="上报机制选择" tabindex="-1">上报机制选择 <a class="header-anchor" href="#上报机制选择" aria-label="Permalink to &quot;上报机制选择&quot;">​</a></h3><p>性能 SDK 也会根据网络能力，选择合适的上报机制。</p><ul><li>在强网环境（如 4G/5G/WIFI），直接进行上报。</li><li>在弱网环境（如 2G/3G），将日志存储到本地，延时到强网下再上报。</li></ul><p>除了网络环境，还会根据 APP 的忙碌状态，决定上报策略。</p><ul><li>让 SDK 根据 APP 忙碌状态，选择合适的上报策略。如果 APP 处理空闲状态，直接上报，如果处于忙碌状态，等到闲时再进行上报。比如凌晨 2-3 点进行上报。</li></ul><p>批量数据上报：</p><ul><li>默认消息数据打到 30 条才上报，或者只在 APP 启动时上报等</li></ul><p>使用 native 接口上报时，SDK 可以复用客户端的请求连接，采集延时上报或者批量上报等策略。实际工作中建议优先使用 native 接口进行数据上报。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>主要介绍了性能 SDK 的设计原则和上报策略</p><ul><li>在性能指标上报之前，也就是请求指标转换为请求参数环节，SDK 内部最好做一次参数校验处理。当初在一个业务接入性能 SDK，上报性能数据时出现了平台看不到对应指标数据的情况，后面定位问题发现，是因为 API 接口取性能指标数据时，把 Windows 对象上的某个方法给字符串化后当作参数了，这个参数内容特别多，直接导致 GET 请求参数过长出现报错，后端并没有拿到请求参数。</li></ul><p>问题：在前面提到的上报策略时，我提到了数据抽样，如果是抽样的数据，怎么能确保性能异常的数据不会被漏掉呢？</p>`,54)])])}const E=s(p,[["render",e]]);export{c as __pageData,E as default};
