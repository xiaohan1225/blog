import{_ as i}from"./chunks/vue3包构成.D7BoeARb.js";import{_ as a,o as l,c as o,ae as t}from"./chunks/framework.ByOFQPzk.js";const f=JSON.parse('{"title":"001 Vue3的升级点","description":"","frontmatter":{"title":"001 Vue3的升级点","date":"2022-06-03T00:00:00.000Z","categories":["Vue"],"tags":["Vue3.0"],"sidebar":"auto"},"headers":[],"relativePath":"note/vue/vue3的升级点.md","filePath":"note/vue/vue3的升级点.md"}'),r={name:"note/vue/vue3的升级点.md"};function n(c,e,s,d,p,u){return l(),o("div",null,[...e[0]||(e[0]=[t('<h2 id="vue3架构" tabindex="-1">vue3架构 <a class="header-anchor" href="#vue3架构" aria-label="Permalink to &quot;vue3架构&quot;">​</a></h2><p>Vue3源码采用<strong>monorepo</strong>方式进行管理，将模块拆分到packages中，这样做的好处如下：</p><ol><li>将多个模块集合到一个仓库，方便维护</li><li>方便版本管理和依赖管理，各模块间相互引用也比较方便</li><li>各个包可以单独安装使用，不需要导入整个vue</li></ol><p><img src="'+i+'" alt="图片加载失败"></p><h2 id="组合式api-composition-api" tabindex="-1">组合式API - Composition API <a class="header-anchor" href="#组合式api-composition-api" aria-label="Permalink to &quot;组合式API - Composition API&quot;">​</a></h2><p>vue2中<code>Options API</code>（即提供props、methods、data、computed、watch等属性供用户使用）的问题：</p><ol><li>复用性比较差，虽然提供mixins和extends，但会出现数据来源不明确和重名问题</li><li>需要使用带有副作用<code>this</code>，存在this指向问题，同时对tree-shaking也不友好</li><li>对于上百行的大型组件来说，当你了解某段逻辑时，你需要不断上下移动阅读，体验很差</li></ol><p>vue3<code>Composition API</code>特点：</p><ol><li>方便抽离，复用性强，可以把干净的逻辑提取到一个单独函数或者文件中，让开发者专注于逻辑内聚问题。</li><li>抛弃this，tree-shaking友好，打包出来体积更小</li></ol><h2 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-label="Permalink to &quot;响应式系统&quot;">​</a></h2><p>vue3采用<code>proxy</code>替代了<code>Object.defineProperty</code>:</p><ol><li>提升了性能，不再需要一次性全部递归拦截</li><li>能拦截到对象属性的新增和删除</li><li>能拦截原生数组的索引、length操作</li></ol><h2 id="diff算法" tabindex="-1">diff算法 <a class="header-anchor" href="#diff算法" aria-label="Permalink to &quot;diff算法&quot;">​</a></h2><p>vue3采用<strong>快速diff</strong>（内部采用了一个最长递增子序列的算法）替换了vue2的<strong>双端diff</strong>，优化了diff效率。</p><h2 id="渲染优化" tabindex="-1">渲染优化 <a class="header-anchor" href="#渲染优化" aria-label="Permalink to &quot;渲染优化&quot;">​</a></h2><p>在渲染方面，vue3提供了<strong>自定义渲染器</strong>，大大提升了扩展能力。</p><h2 id="编译优化" tabindex="-1">编译优化 <a class="header-anchor" href="#编译优化" aria-label="Permalink to &quot;编译优化&quot;">​</a></h2><ul><li>Block和patchFlag：为动态节点打上补丁标志，即patchFlag，同时还提出了block的概念，block本质上是一个虚拟节点，但它会多出一个dynamicChildren数组，会收集它所有的动态子代节点，比对的时候会忽略DOM层级结构的，所以对于带有v-if、v-for等结构化指令的节点也作为block的角色。</li><li>静态提升：将静态虚拟的节点提升到render函数之外，这样能够减少更新时创建虚拟DOM带来的性能开销和内存占用。</li><li>预字符串化：在静态提升的基础上，当模板中包含大量连续纯静态的标签节点时，将这样静态节点序列化成字符串，然后通过innerHTML进行设置，这样做能够减少创建虚拟节点产生的性能开销和内存占用。</li><li>缓存内联事件处理函数：可以避免不必要的更新</li><li>v-once指令：缓存虚拟节点，避免组件更新时重新创建虚拟DOM的性能开销，同时带有v-once指令的节点不会被父级block收集，所以不会参与diff操作，避免无用的diff开销。</li></ul><h2 id="新增组件" tabindex="-1">新增组件 <a class="header-anchor" href="#新增组件" aria-label="Permalink to &quot;新增组件&quot;">​</a></h2><ul><li>Teleport：可以将指定内容渲染到特定容器中，而不受DOM层级的限制。</li></ul><h2 id="对typescript支持更加友好" tabindex="-1">对TypeScript支持更加友好 <a class="header-anchor" href="#对typescript支持更加友好" aria-label="Permalink to &quot;对TypeScript支持更加友好&quot;">​</a></h2><p>vue2源码采用Flow做类型检测，对TypeScript支持并不友好，而Vue3采用TypeScript进行重写，对TS的支持更加友好。</p><h2 id="vue3的核心包介绍" tabindex="-1">vue3的核心包介绍 <a class="header-anchor" href="#vue3的核心包介绍" aria-label="Permalink to &quot;vue3的核心包介绍&quot;">​</a></h2><ol><li>compiler-core：与平台无关的编译核心包</li><li>compiler-dom：针对浏览器平台的编译包</li><li>compiler-sfc：解析单文件</li><li>compiler-ssr：服务端渲染的编译模块</li><li>reactivity: 响应式系统</li><li>template-explorer：一个开发工具，用于调试编译器输出</li><li>vue-compat: 用于兼容vue2的包</li><li>runtime-core: 与平台无关的运行时核心包</li><li>runtime-dom: 针对浏览器平台的运行时包，包括DOM API和事件处理等</li><li>runtime-test: 用于测试的运行时包</li><li>server-renderer: 服务端渲染包</li><li>shared: 共享工具包</li><li>vue: 完整的Vue包，包含编译器和运行时</li><li>ref-transform: 一个用于将ref转换为普通变量的编译器插件，以便在模板中使用普通变量</li><li>size-check: 一个用于检查Vue应用大小的工具</li></ol><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h2>',25)])])}const v=a(r,[["render",n]]);export{f as __pageData,v as default};
