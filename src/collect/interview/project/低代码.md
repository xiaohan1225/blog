## 为啥不用 drag 事件

1. 拖拽的复杂性 

- drag 事件的实现较为复杂。它通常涉及到更多的状态管理和交互细节，比如拖拽开始（dragstart）、拖拽结束（dragend）、拖拽移动（dragover）等事件的处理。这些事件需要对元素的动态位置、样式以及与其他组件的互动进行精确控制。与其依赖于这些复杂的事件处理机制，选择 mouse 事件能够更简洁地实现拖拽功能。
- 在很多低代码平台中，用户的交互场景常常是“简单拖拽、放置”，而拖拽事件的处理需要针对不同的浏览器、设备和屏幕尺寸进行细致的兼容性测试，增加了开发和维护的复杂度。

2. 更细粒度的控制
- mouse事件（如mousedown,mousemove,mouseup） 可以让开发者对拖拽过程中的各个细节有更精确的控制。例如，可以在鼠标按下时开始记录拖拽的起点，在鼠标移动时动态更新拖拽对象的位置，在鼠标松开时完成放置。
- drag事件通常会有一定的限制，比如对拖拽的元素的默认行为处理和浏览器的优化，开发者可能需要通过更多的代码来重写或修改这些行为。而mouse事件能让开发者完全控制拖拽的各个步骤，确保用户交互流畅且符合预期。

3. 性能优化
- 使用mouse事件通常会带来更好的性能优化。在拖拽过程中，mousemove事件的触发频率较高，开发者可以有针对性地进行性能优化，例如通过节流(throttling)或防抖(debouncing)来减少不必要的DOM更新。
- drag 事件本身可能会导致频繁的重绘和重排，尤其是在拖拽过程中需要频繁更新元素的位置和状态时，性能开销可能较大。相比之下，mous事件可以让开发者更有针对性地控制哪些元素需要更新，哪些可以跳过，优化性能表现。

4. 兼容性和稳定性
- 在一些浏览器或设备中，drag事件的表现可能会有所不同，尤其是在触摸设备和桌面设备之间的差异。mouse事件通常具有更广泛的兼容性，并且行为在不同浏览器之间更为一致。
- 对于低代码引擎来说，简化跨平台和跨浏览器的兼容性问题是至关重要的，使用mouse事件可以避免一些drag事件带来的潜在问题，比如拖拽过程中不容易捕捉到的细节或特殊行为。
5. 用户体验
- 低代码平台的目标是让用户能够直观、简便地进行操作。通过mouse事件可以实现更直观、流畅的拖拽体验，例如在拖拽开始时，通过鼠标按下事件获取用户意图，在拖动过程中动态展示拖拽反馈，用户释放鼠标时再放置元素。
- drag 事件更多的是基于浏览器内置的拖拽操作，它可能不如使用mouse事件时那样灵活，无法很好地满足低代码平台要求的自定义交互需求。

## 黑名单设置
- 通过 `blackListSet` 列出不可访问的全局对象（如 document、fetch）
- 在沙箱中访问这些对象时返回一个黑洞代理，避免报错

```js
const blackListSet = new Set([
  'top',
  'self',
  'parent',
  'global',
  'globalThis'
  'document',
  'fetch',
  'window',
  'frames',
  'XMLHttpRequest',
  'MutationObserver',
]);
```

## 黑洞代理
- 任何对黑名单对象的访问，都会返回一个虚拟的“黑洞对象”
- 黑洞对象会吞掉任何访问或调用，而不会抛出异常

```ts
function createBlackHole() {
  return new Proxy(
    function () {
      return createBlackHole();
    },
    {
      get(_, p) {
        if (p === 'toString' || p === Symbol.toPrimitive) {
          return createBlackHole();
        }
      },
    }
  )
}
```

## 沙箱代理
- 使用 `Proxy` 创建沙箱对象，拦截用户代码对全局对象的访问。
- 对于黑名单对象，返回黑洞代理；对于正常对象，返回真实值或绑定后的函数。

```ts
function createMockWindow(base?: object) {
  const win: any = new Proxy(Object.assign({}, base), {
    get(target, p) {
      if (globalVarNames.has(p)) return win;
      if (blackListSet.has(p as string)) return createBlackHole();
      return Reflect.get(window, p);
    }
  })
  return win;
}
```

## 沙箱运行代码
- 使用 `with` 语句注入沙箱对象，将用户代码与沙箱隔离。
- 通过严格模式（'use strict'）防止意外的全局变量泄漏。

```ts
function runUsersCode(code: string) {
  const finalCode = `with(this) {

    return (function() {
      'use strict';
      return (${code});
      }).call(this);
  }`
  return new Function(finalCode);
}
```