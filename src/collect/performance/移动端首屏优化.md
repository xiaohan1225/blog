我们可以先用 `performance 相关API` 来统计下页面的 `DOM 加载时间`。

旧版统计方法，使用 `performance` (已废弃):
```js
window.onload = () => {
  console.log(performance.timing.domComplete - performance.timing.navigationStart);
}
```

新版统计方法，使用 `PerformanceObserver` (推荐使用):

```js
// 统计性能
window.onload = () => {
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach(entry => {
      console.log(entry.domComplete);
    })
  })
  observer.observe({ entryTypes: ['navigation'] })
}
```

如果 `DOM加载时间` 过长，比如超过 1s，就需要考虑进行优化了，优化的话主要从以下几个方向进行：
- 网络资源请求
- 构建工具
- 缓存
- 渲染
- 

## 一、网络资源请求
### 1.1 减少请求个数
图片采用 `雪碧图(CSS Sprites)`，`base64`。

### 1.2 加快请求速度
将图片上传到 `cdn`。

## 二、构建工具
这里以 `webpack` 为例。
### 2.1 

## 异步组件

## 静态资源cdn

## 首屏优化
构建工具：
1. 按需打包 组件库 lodash工具库 IgnorePlugin moment
2. sourcemap 生产none
3. babel-loader开启缓存
4. noParse
5. bundle hash
6. splitChunks
7. tree-shaking
8. external 配置vue.config.js  在html模板中加入定义好的cdn变量使用的代码

网络请求：
- 减少请求个数：base64 缓存
- 请求过程优化：gzip CDN

静态资源：
1. 图片 
  - base64 
  - 雪碧图（CSS Sprites） 
  - WebP
    - 特点：色彩丰富，支持有损压缩和无损压缩， PNG 一样支持透明，像 GIF 一样可以显示动态图片，集多种图片文件格式的优点于一身
    - 缺点：1. 兼容性 2.WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。
    - 应用场景：优雅降级处理，由服务器根据 HTTP 请求头部的 Accept 字段来决定返回什么格式的图片
渲染：
- 预渲染
- ssr
用户体验：
- 骨架屏
- 懒加载

## 缓存
