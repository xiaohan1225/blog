## 引言
在性能影响因素里，后端接口的耗时也不可忽略。以某电商 APP 列表页为例，后端接口返回数据需要 200ms，参考首屏秒开的标准，它就占了 20% 的时间。

以前一直采用的是缓存或者静态化的方案去解决，能不请求实时数据就不请求，用历史数据去代替。直到我遇到了机票和酒店相关的业务，因为它们的价格和库存会实时变化，如果页面打开时间长，用户会担心买不到合适的机票，转而离开去往竞品购买。

采用预请求、预加载和预渲染的方式来解决问题。

## 预请求

想要通过拉取后端接口来降低首屏时间，我们需要先实现接口的预加载，而实现它要先解决预请求的逻辑，也就是统一拼装请求参数的逻辑。

具体怎么进行统一拼参呢？

以机票业务为例，进入列表页后，输入出发地和目的地后，比如从北京到深圳，选择日期为 2021-06-06，前端应用通过解析页面 URL 路径，拿到所需的一些参数。调用 Native 的 schema 进入参数解析环节，找到 Native 对应的协议和参数，然后再通过参数初始化，拼装成对应的参数。

面临的一个问题时，没有预请求的页面 URL 参数，也没法通过 Native 获取到。

我们使用了同样的流程，将预请求封装成 preReq 功能，把所有的功能都包括起来，用同一份代码实现。

- 如果你已经使用了 Native 统一请求，直接走客户端逻辑发送即可。
- 如果没有走 Native 统一请求，我们可以借助 axios 库函数来完成。

## 预加载

在完成预请求参数拼装之后，紧接着就是预加载逻辑了，首先是要把握预加载的时机。以机票列表页为例，我们需要判断用户操作对的特定路径。如果用户命中了这个特定路径，就会走预加载去加载列表页的接口。

这个路径是我们和后端的一个约定，有具体的编号。比如用户进入首页编号是 0，输入出发地和目的地编号是 1，选择日期的编号是 2，切换关键词的编号是3。后端在用户进入页面页时，以接口的方式返回一个操作路径的数组，当用户的操作路径命中这个数组后，选择了出发地和目的地，并且输入了日期，接下来开始进行预加载。

当用户点击“开始搜索”后，前端应用就会去判断有没有预加载下级页面（搜索页面）的接口，是否有预加载数据，数据有没有过期。如果没有可用的预加载数据，此时我们进行一次搜索页的预加载，减少从列表页到搜索页的跳转时间和搜索页的初始化时间。

如果 Native 已经提供这个工具，我们直接使用 Native 的预加载接口即可，反之，我们还是需要扩展 axios 库函数来实现。在 axios 进行数据请求后，封装一个 afterFetch 的钩子方法，负责将加载完成的数据存储到内存/本地，供下一个路由使用。

## 预渲染

预渲染是指在用户访问这个页面之前，完成页面渲染的准备。

以机票列表页为例，比如说用户命中特定路径的时候，前端会进行判断并会把搜索结果页先渲染出来，只不过在列表页可视区域下方，用户是不可见的。

当用户点击开始搜索时，前端会去 check，如果已经有了预渲染的页面，只需要把页面显示出来的操作，push 到顶层即可，这样就省去了初始化页面、请求数据和渲染的时间。

“客户端”渲染技术：
- 它有别于 CSR，而是NSR（Native side rendering，客户端渲染）

NSR 是怎么实现的呢？
- 首先是模板和数据的准备，用户点击页面链接进入后，这个页面的所有资源是准备好的，具体可以使用离线包或者预请求和预加载的方式。
- 由于页面是动态的而 URL 是静态的，需要实现一种页面和模板的映射机制，一般为多对一
- 在 Native 侧实现一种类似前文 SSR 方案的 Native 的本地渲染服务

在使用时，前端代码不需要做什么改动，业务侧前端工程师接入 NSR，把后置流程准备好就可以了，所谓的后置流程，就是指渲染好下级页面后放置在可视区域之外。

## 长列表性能优化

NSR 是在端内渲染的场景，如果是端外怎么办呢？端外就是纯前端的渲染了。

公司有个文档内容展现平台，在对文档进行展现时，需要用到虚拟页，即要展示的文档的页码会根据页面内容动态变化，这样同一篇文档，在不同平台上显示，需要切割分页，但该操作需要一定的时间。所以，最好的办法是，当展示第1页的时候，就预先渲染第3页的内容。在展示第T页的时候，在可视范围之外，做T+2页的数据切割，切割完进行渲染，渲染完成后放在原地，等点击第T+2页时，移动回来。

## 小结
以上就是预请求、预加载及预渲染相关的内容。

在实际当中，你可能会遇到预加载和预渲染需要降级的问题，比如没有拿到数据的兜底兼容流程，可以继续使用 CSR，同时如果在端外无法使用离线包，则使用 SSR 是一种很好的替代方案。