
作为一名前端工程师，我们常说“性能即体验”。但“性能”这个词太宏大，具体落实到用户感知的层面，其实主要就是两件事：**我打开页面的速度快不快？界面操作顺不顺畅?**

而在前端性能指标中，与此相对应的分别是**白屏指标**和**卡顿指标**。

## 1、白屏时间、首屏时间和卡顿时间的区别

**想象一下你去机场坐飞机：**
- **白屏时间**：从机场大厅排队走到安检柜台前的那段时间。
- **首屏时间**：过机场安检的时间。
- **卡顿时间**：排队停止了。比如前面的人突然停下找身份证，也就是排队的队伍停止了，你就得等着，这就是卡顿。

**具体反映在用户体验上：**
- **白屏时间**：用户从点击链接到看到第一个字符出现的时间。
- **首屏时间**：用户从点击链接到看到主要内容出现的时间。
- **卡顿时间**：用户在操作过程中，由于浏览器或 App 处理其他任务而导致的延迟。比如点击按钮后，页面很久才有反应，这就是卡顿。

## 2、白屏时间

在浏览器中，**白屏时间**指的是从用户按下回车（或点击链接）开始，到页面上出现第一个字符的时间。

**怎么采集白屏时间呢？**

**浏览器环境：**

我们可以利用浏览器的 `Performance API` 来计算：
> **白屏时间 = `domLoading` - `navigationStart`**

其中，`domLoading` 表示**浏览器开始解析 DOM 结构的时间**，首屏时间就是指浏览器开始解析 DOM 结构的时间减去导航开始的时间。

```js
function getDomLoadingTime() {
  if (!window.performance || !window.performance.timing) {
    return null;
  }
  
  const timing = window.performance.timing;
  const navigationStart = timing.navigationStart;
  const domLoading = timing.domLoading;
  
  if (navigationStart === 0 || domLoading === 0) {
    return null;
  }
  
  return domLoading - navigationStart;
}

window.addEventListener('load', function() {
  const domLoadingTime = getDomLoadingTime();
  if (domLoadingTime) {
    console.log('DOM 开始解析时间:', domLoadingTime, 'ms');
  }
});
```

**App (WebView) 环境：**

与浏览器环境不同的是，在 `APP(Webview)` 环境中，多了一个启动浏览器内核，也就是 `Webview` 初始化的过程，这就好比你要过安检，安检员需要先把安检机器给打开。 

所以在这个环境下，检测白屏时间需要 APP 端配合。在 APP 创建 Webview 时，需要打一个点，在开始建立网络连接时，再打一个点，这两个点之间的差值，就是初始化的耗时，在计算白屏时间的时候，需要加上这部分的耗时。

> 当然，我们也可以通过**并行初始化**的方案，来规避掉这部分的耗时。也就是在 APP 启动时，并行初始化 `Webview`，并放入 `Webview` 池，当用户需要打开 H5 页面时，直接从池子里取出来，而不需要重新初始化。当然，也需要对 `Webview` 池进行最大容量限制，避免内存占用过多。
 
## 3、卡顿

**卡顿**很好理解，直白点来说就是页面“卡”住了。比如用户点击了一个按钮，但是页面过了 3-4s 才有反应，或者页面某些动画看起来很不流畅，这都是卡顿的现象。


**怎么判定卡顿呢？**

FPS（Frames Per Second），即**每秒帧数**，是衡量页面流畅度的一个指标。一般来说，**FPS 超过 60 就可以认为是流畅的**，也就是单帧渲染时间在 16.6ms（1000ms / 60） 以下。

不过也有一些极端情况，比如玩游戏时，前 0.9 秒就渲染了 59 帧，单最后 0.1 秒一帧都没渲染，这样平均下来 FPS 还是 59，但用户在那 0.1 秒会感觉到明显的“掉帧”。所以，为了更准确的衡量卡顿，我们不能简单用单帧平均渲染时间来判断。

**浏览器环境：**

浏览器并没有直接提供 FPS 指标，但是我们可以通过 `requestAnimationFrame` 来变相计算。

```js
// 统计FPS
function calculateFPS() {
  let lastTime = performance.now();
  let frameCount = 0;

  function animate() {
    const currentTime = performance.now();
    const deltaTime = currentTime - lastTime;

    if (deltaTime >= 1000) {
      const fps = frameCount / (deltaTime / 1000);
      console.log('当前 FPS:', fps);
      lastTime = currentTime;
      frameCount = 0;
    }

    frameCount++;
    requestAnimationFrame(animate);
  }

  animate();
}
```


> **判定标准**：如果连续 3 帧的刷新频率都低于 20 FPS，且保持恒定，往往意味着出现了卡顿。

**App 环境：**
App 原生可以拿到每一帧的具体渲染耗时。
> **判定标准**：
> *   一般卡顿：连续 5 帧渲染时间超过 50ms。
> *   严重卡顿：单帧渲染时间超过 250ms。

## 4、如何采集用户的网络环境？

用户的网络环境有很多种，比如 5G、4G、WiFi、3G/2G 等。我们可以通过采集用户的网络环境，来了解用户的真实网络情况，从而更好的优化用户体验。

一般来说，我们可以采取**图片测速法**来采集用户的网络环境。
- 加载两张图片，一张极小的（1x1像素），一张稍大的（3x3像素）。
- 记录图片请求开始到 `onLoad` 完成的时间。
- 计算速度：`文件大小 / 加载时间 = 网速`。
- 取平均值，把两个数据取个平均值，减少误差。

拿到用户数据后，我们可以画出用户的网速分布图，这为我们优化用户体验提供了数据支撑。比如视频播放时，不同网络环境下的用户，分别加载不同清晰度的视频，高清、标清、流畅等。

## 总结
