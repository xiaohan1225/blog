
常见的前端指标有 `FP`、`FCP`、`LCP`、`CLS`、`TTFB`、`INP` 等。

| 指标 | 含义 |
|---------|---------|
| FP (First Paint)   | 页面渲染第一个像素点的时间   |
| FCP (First Contentful Paint)  | 页面渲染出第一个有意义内容的时间  |
| LCP (Largest Contentful Paint)  | 页面最大可见内容元素渲染完成的时间  |
| CLS (Cumulative Layout Shift)  | 页面布局变化的累积分数  |
| TTFB (Time to First Byte)  | 从请求发出到接收第一个字节的时间  |
| INP（Interaction to Next Paint）  | 页面首次交互（点击链接、按钮等）到浏览器实际响应的延迟  |


那么我们在实际项目中如何采集到它们呢？

## 指标采集方案

### 统计 FP、FCP、TTFB

`Performance` 是浏览器提供的原生 API，我们可以使用 `window.performance` 采集性能数据。

```js
window.addEventListener('load', () => {
  const performance = window.performance;
  const timing = performance.timing;

  const metrics = {
    fp: timing.domLoading - timing.navigationStart,  // FP
    fcp: performance.getEntriesByName('first-contentful-paint')[0]?.startTime || 0,  // FCP
    ttfb: timing.responseStart - timing.requestStart, // TTFP
  };

  // 使用 sendBeacon 上报到服务器
  navigator.sendBeacon('/api/performance', JSON.stringify(metrics));
});
```

### 统计 CLS


```js
let cls = 0;
const observer = new PerformanceObserver((entryList) => {
  entryList.getEntries().forEach((entry) => {
    console.log('entry: ', entry);
    if (!entry.hadRecentInput) {  // 排除用户输入引起的偏移
      cls += entry.value;
      console.log('当前 CLS 值:', cls, entry);
    }
  });
});
observer.observe({ type: 'layout-shift', buffered: true });
```

### 统计 INP

```js
const interactions = [];  // 存储每个交互的最长 duration
const observer = new PerformanceObserver((list) => {
  list.getEntries().forEach((entry) => {
    if (entry.interactionId) {  // 只处理用户交互事件
      console.log('交互延迟:', entry.duration, entry);
      interactions.push(entry.duration);  // 收集 duration（实际需按 interactionId 分组取 max）
    }
  });
});
observer.observe({ type: 'event', buffered: true, durationThreshold: 16 });  // 最小阈值 16ms

// 计算 INP 的函数（在页面卸载时调用）
function calculateINP() {
  if (interactions.length === 0) return 0;
  interactions.sort((a, b) => a - b);
  const percentile = interactions.length < 50 ? interactions.length - 1 : Math.floor(interactions.length * 0.98) - 1;
  const inp = interactions[percentile];
  console.log('最终 INP 值:', inp);
  return inp;
}

window.addEventListener('beforeunload', calculateINP);
```

### Web Vitals

先在项目中安装下 `web-vitals` 库。

```bash
npm install web-vitals -S
```

```js
import { onCLS, onFCP, onLCP, onTTFB } from 'web-vitals';

onCLS(console.log);
onFCP(console.log);
onLCP(console.log);
onTTFB(console.log);
```

打印结果如下：

![图片加载失败](../../../assets/images/performance/web-vitals.png)


## 采样注意点
- 使用 `Performance` 要注意下兼容性问题，在低版本浏览器中需要用 `Date.now()` 手动计时。
- 使用 `Chrome DevTools` 的 `Performance 面板`验证采集准确性。

- 内网通过 `Chrome DevTools` 观察首屏时间，这样导致内外网环境不同，首屏时间受到影响，可能会得出“我们网站的首屏时间没问题” 这样的错误结论。
- 使用的是调试工具，跟用户的访问方式不同。
- 测试机观察首屏时间的手机只有几种，而真实用户的机型种类有非常多。


如何了解用户的首屏时间？

大量用户的首屏时间分布是怎么样的？

性能差的用户首屏时间是多少？

