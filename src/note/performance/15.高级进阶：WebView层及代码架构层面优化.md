## 引言

介绍 webview 层面的优化和前端架构性能方面的调优。

webview 是我们经常使用到的工具，在我们开发 App 过程中起到非常重要的载体作用。

前端架构的某些因素也会严重影响我们的前端性能体验。

## webview 性能优化

webview 是一个基于 webkit 引擎、展现 web 页面对的控件。App 都打开 webview 对的第一步不是请求连接，而是启动浏览器内核。

所以会导致，同一个页面，在 App 端外反而比端内打开速度更快。因为在 App 内，webview 还需要先进行初始化，这需要时间，且这个初始化时间还和 webview 类型有关，如果是 WKWebview，时间会更短，但基本也会占首屏时间的30%左右。

需要进行 webview 优化：包括资源缓存、并行初始化、资源预加载和数据接口请求优化，以及更换 webview 内核等。

缓存选用方面比较简单，直接选用浏览器默认缓存，而更换 webview 内核，往往会因为需要进行灰度处理，必须一段时间内并行两套 webview 方案，很容易出现系统性风险。

### 并行初始化

并行初始化是指用户在进入 App 时，系统就创建 webview 和模板，这样 webview 初始化和 App 启动就可以并行进行，这大大减少了用户等待时间。

如果是使用 native 开发的应用，根据用户在首页的访问路径，选择初始化策略，操作体验会更好。以携程 App 为例，假设用户进入首页后，停留在西双版纳自由行区域，直接加载 webview和模板，两者同时运行，此时首屏主要工作就变成加载接口请求数据和渲染模板两部分的工作了。

为了减少 webview 再次初始化的时间，我们可以在使用完成后不进行注销，将里面的数据清空，放进 webview 池子里面，下次使用时，直接拿过来注入数据使用即可。使用时需要对 webview池子进行容量限制，避免内存占用过多。

如果把初始化直接放到 UI 线程，会导致打开页面卡死甚至 ANR（Application Not Responding，应用无响应），建议将初始化过程放进子线程中，初始化借宿后才添加到 view 树中。

### 资源预加载

资源预加载是指提前在初始化的 webview 里面放置一个静态资源列表，后续加载东西时，由于这部分资源已经被强缓存了，页面显示速度会更快。
- 一定时间内（如1周）不变的外链
- 一些基础框架，多端适配的 JS（如adapter.js）
- 性能统计的 JS（如perf.js）或者第三方库（如vue.js）
- 基础布局的css，如 base.css

一般在 App 启动时，系统就加载一个带有通用资源模版的 HTML 页面，怎么避免因变化导致 App 频繁发布版本的麻烦呢？
- 一个办法时通过静态资源预加载后台进行管理，我们不需要从0到1搭建，只需要在离线包后台添加一个栏目即可。

前端工程师进行静态资源预加载后台发布出一个静态资源列表页，然后把它的 URL 提供给 App，App启动时会对这个 URL 下页面中的静态资源进行预加载。不要小看这一点，通过这种做法，将列表13个文件缓存后，首屏时间从1050ms降低到900ms。

### 数据接口请求优化

数据接口请求优化主要是通过同域名策略和客户端代理数据请求来实现。
- 同域名策略是指前端页面和资源加载，尽量和 App 使用的数据接口在同一个域名下，这样域名对应的 DNS 解析出来的 IP，由于已经在系统级别被缓存过了，大大降低了加载时间。比如 58 App 客户端请求域名主要集中在 api.58.com，请求完这个地址后，DNS 将会被系统缓存，而前端资源的请求地址在 i.58.com，打开 webview 后由于请求了不同的地址，还需要重新去 DNS 服务器查询 i.58.com 对应的 IP，而如果前端页改到 api.58.com，DNS查询的时间可以从原来的将近80ms降低到几ms。
- 客户端代理数据请求则是指把前端的数据请求拦截起来，通过客户端去发送数据请求。通过客户端代理数据请求，可以把前端的ajax请求提前到与页面加载同时进行，由客户端请求数据，等 H5 加载完毕，直接向客户端索要数据即可。如此依赖，便缩短了总体的页面加载时间。
  - Android 端可以重写 WebViewClient 的 shouldInterceptRequest 方法。
  - ios 端没有类似的方法，只能通过私有 API 方案、自定义协议方案和 LocalWebServer 来实现。

## 前端架构性能调优
前端架构性能优化是指通过在前端开发、编译、打包、发布环境所做的优化，以此来提升前端性能的方案。

### 长列表性能优化
一般 Vue 会借助 Object.defineProperty 这个 ES5 规范对的方法，对数据进行劫持，即通过某个对象定义一个新属性或者修改一个属性，实现视图响应数据的变化。可以使用 Object.freeze 方法冻结对象。

### 打包优化
通过 webpack 插件来完成。通过 `webpack-bundle-analyzer`分析打包结果进行优化。
- 生产环境打包关闭 souremap，即 `productionSourceMap: false`。

## 小结
以上就是 webview 性能优化和代码架构层的优化。

可以将 webview 放到独立进行中，避免内存泄漏。当然，webview 独立进行的话，就需要解决进程间调用问题，一般可以直接使用 Aidl 来解决。