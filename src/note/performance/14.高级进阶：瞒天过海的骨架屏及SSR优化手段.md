## 引言

骨架屏可以使用户预期到接下来要展示的内容和结构，让用户觉得页面加载快了，而 SSR 则可以让白屏时间大幅缩短。

具体该怎么实现骨架屏和 SSR 呢？在实际工作中如何落地操作呢？

## 使用骨架屏方案优化页面性能

为了让骨架屏内容和页面结构更类似，提升用户体验，我们一般采用的是图片骨架屏。

## 图片骨架屏的实现

设计师针对这个页面制作一张离线包图片，在 Webview 启动时，客户端把这张图片覆盖在页面上，页面开始进入请求资源的流程，当页面 webview 加载完成或者前端页面通知客户端加载完成时，客户端通过渐变动画隐藏这张图片，将准备好对的页面展现给用户。

实现步骤：
1. 先让 UI 设计师设计一张对当前页面对应离线包的图片作为骨架屏展示图片
2. 在业务需求开发过程中，前端工程师拿到图后，把这张图片上传到 CDN 上面
3. 在客户端代码增加启动时读取图片骨架屏配置文件，配置的大致逻辑是，先传入设备分辨率，比如 400x500。

```json
// 传入设备分辨率 ratioWidth: 400, ratioHeight: 500
{
  "code": 0, // 0 代表请求陈工，-1 代表图片骨架屏功能关闭
  "data": {
    "m.58.com/enjoy-given/eg/index.html": { // 页面 url
      "rege": "#/content/index",
      "routes": {
        "#/content/index": {
          "downloadUrl": "https://m.58.com/pic.png?400*500", // 骨架屏图片地址
          "imgName": "pic.png",
          "id": "10001"
        }
      }
    }
  },
  "msg": ""
}
```

当客户打开url时，客户端对url进行解析，取得对应的 host 和 pathName，然后将两个数据分别与 data 和 routes中的数据作比较，如果都匹配上，说明要展示骨架屏。

注意点：
1. 注意区分首次使用和二次使用：
  - 首次使用的话，客户端遍历上述配置文件，下载数据中对应图片即可
  - 二次使用时，需要那当前配置文件对比之前的配置文件，如果图片名称不同，需要下载新的图片
2. 需要客户独胆在内存中建立图片，以加快图片骨架屏的加载速度
3. 图片骨架屏展示过程中会出现拉伸问题。这时因为分辨率不同造成的，我们可以让 App 在获取配置文件时，加上当前页面的分辨率，这样接口会根据分辨率返回最合适的图片。

## 使用及注意事项
骨架屏方案，非常适合资源加载时间长的页面。比如列表页的首屏内容有很多个数据接口、筛选项、精选数据、列表数据等，这时候一定要用骨架屏，而对于一些 SSR 页面，因为白屏阶段比较短，可用可不用。

骨架屏使用起来比较简单，UI 对应出一个骨架屏的图片，然后上传到 CDN，并给出页面路径和文件路径，生成配置文件给客户端，客户端根据配置加载骨架屏即可。

骨架屏中的内容结构，应该只是首屏对的内容结构，不是整个页面的内容结构，反之会造成图片骨架屏体积过大，加载骨架屏时间过长的问题。

骨架屏的问题，比如加载异常时没有提示，或者展示时间过长，因为他不会影响白屏时间，我们很难发现，所以骨架屏什么时候展示和什么时候销毁，客户端要以日志形式记录下来，上传到性能监控平台，这样定期去看一下日志，则可以发现问题。

## 使用 SSR 方案优化页面性能
一个 Web页面的渲染主要由客户端或者浏览器端来完成。大概过程是，客户端从服务端请求到 index.html，然后加载脚本文件，web应用通过 ajax 请求到页面数据，并把对应对的数据填充到模板中，最终形成完成的页面来呈现给用户。

SSR则把数据请求放在了服务端，服务端收到返回结果时，把数据填充到模板形成完整的页面，由服务端把拼接完成的完整页面返回给客户端。

## SSR 的实现及使用
手机业务迭代开发速度比较快，我们希望将 SSR 开发的一些配置能够封装起来，让前端工程师介入成本降低。

Nuxt.js 是一款基于 Vue 的SSR 开源框架，使用 webpack 和 Node.js 进行封装，其中预设了开发服务端渲染应用所需要的各种配置。

## 白屏时间 100ms 的SSR优化
- 利用服务端的性能优势，尽量在服务端完成资源加载、首屏切分等工作。
- 利用服务端统计缓存机制，对数据接口、页面和组件做缓存。

- 服务端渲染的最大优势，就是后端服务性能要远高于手机，所以请求数据接口和渲染时，耗时会更短。
- 服务端缓存与客户端最大不同是，服务端属于统一公用，也就是说，只要某一个用户访问过一次，后续所有用户的访问都可以使用这份缓存。

- LRU 属于页面级缓存，对于数据统一性页面，利用 LRU-Cache 可以缓存当前请求的数据资源。
- 使用 Redis 可以对跨页面的数据接口进行缓存，将整体渲染时间再减少100ms。因为SSR应用程序部署在多服务、多进程下，该进程下的缓存并不是共享对的，这就造成缓存命中效率低下，而使用 redis 可以解决这个问题，进而实现更好的跨页面数据缓存。

## 小结
以上就是骨架屏和SSR性能优化方案。

- SSR需要你对后端只是，尤其是 Node.js 只是有很好的把握，且具备一定的数据接口设计规划和设计能力
- SSR渲染对进行的页面，一些实践还在绑定中，有可能出现操作没反应的情形。
