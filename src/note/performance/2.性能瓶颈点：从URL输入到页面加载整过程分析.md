问题：团队对首屏要求是 1200ms，目前首屏时间长达 2s，精简了首屏内容，合并了请求资源，对图片尺寸也进行了压缩优化，但最后的首屏时间还是没有降下来，为什么？

相对 Web 前端进行性能优化，除了了解性能体系、关键性能指标之外，还需要了解页面加载全过程。

## 页面加载全过程

### 1. 客户端发起请求阶段
- 查询本地缓存，是否存在这个网站

本地缓存是前端性能的瓶颈点之一，因为它可以让静态资源加载更快，当客户端发起一个请求时，静态资源可以直接从客户端中获取，不需要再向服务器请求。

一个列表页请求：DNS 时间 385ms，TCP三次握手 + TLS协商 436ms，数据返回 412ms，一个请求下来大约是 1233ms。这还是在强网（WIFI/4G）情况下，如果是在弱网（2G/3G）情况下，一个请求连接都需要 2s，使用缓存的话，几乎可以说是几毫秒内完成请求。
- 强缓存：浏览器在加载资源时，根据请求头的 expires 或 cache-control 判断资源是否命中强缓存，若命中，直接从缓存中获取资源，不会发请求到服务器。
- 协商缓存：浏览器会发送一个请求到服务器，通过 last-modified 和 etag 判断资源是否命中协商缓存，若命中，服务器会将这个请求返回，但不返回资源内容，浏览器从缓存中加载资源。如果未命中，无论是资源过期或者没有资源，都需要向服务器发一次请求，等待返回这个资源。


- DNS 解析：DNS之所以会成为前端性能瓶颈点，是因为每进行一次 DNS 查询，都要经历从手机到移动信号塔，再到认证 DNS 服务器的过程。节省时间的办法就是让 DNS 查询走缓存，幸好浏览器提供了 DNS 预获取的接口，我们可以在打开浏览器或者 WebView 的同时就进行配置。
- TCP 连接
- HTTP 请求
  - 最大的瓶颈点来源于请求阻塞，请求阻塞就是浏览器为保证访问速度，会默认对同一域名下的资源保持一定的连接数，请求过多就会进行阻塞。（浏览器同域名的连接数限制，一般是 6个，如果当前请求数多于 6 个，只能 6 个并发，其余的得等最先返回的请求后，才能做下一次请求）。
  - 做一些域名规划很重要，可以先看看当前页面需要用到哪些域名，最关键的首屏中需要用到哪些域名，规划下域名的发送顺序。
  - 域名散列：通过不同的域名，增加请求并行连接数。将静态服务器地址 pic.google.com，做成支持 pic0-5 的 6 个域名，每次请求时随机选一个域名地址进行请求，因为有 6 个域名同时可用，最多可以并行 36 个连接。当然，这个域名个数不是越多越好，太分散的话又会涉及到多域名无法缓存静态资源的问题。

### 2. 服务器处理请求阶段
服务端数据处理阶段是指 WebServer 接收到请求后，从数据存储层取到数据，再返回给前端的过程。

瓶颈点：是否做了数据缓存处理、是否做了 Gzip 压缩，以及是否有重定向。

#### 数据缓存
- 借助 Service Worker 的数据接口缓存，Service Worker 是浏览器的一个高级属性，本质上是一个请求代理层，它存在的目的就是拦截和处理网络数据请求。
- 借助本地存储的接口缓存，对数据时效性要求不高的页面，第一次请求到数据后，程序将数据存储到本地存储，下一次请求的时候，先去缓存里面取数据，如果没有再向服务器发起请求。
- CDN：它的基本思路是通过在网络各处放置节点服务器构造一个智能虚拟网络，将用户的请求导向离用户最近的服务节点上。
其它：字段精简。

为什么数据缓存会成为性能瓶颈点呢？
- 每请求一次数据接口，需要从客户端到后端服务器，再到更后端的数据存储层，一层一层返回数据，最后再到客户端，耗时很长。

#### 重定向
重定向是指网站资源迁移得到其它位置后，用户访问站点时，程序自动将用户请求从一个页面转移到另外一个页面的过程。

分类：
- 服务端302重定向
- meta 标签实现的重定向
- 前端 JavaScript 通过 window.location 实现的重定向

重定向会引发新的 DNS 查询，导致新的 TCP 三次握手和 TLS 协商，以及产生新的 HTTP 请求，而这些都会导致请求过程中更多的时间，进而影响前端性能。

### 3. 客户端页面渲染阶段

当前服务端对数据加工聚合处理后，客户端拿到数据，接下来就会进入解析和渲染阶段。
- 解析：HTML 解析器把页面内容转换为 DOM 树和 CSSOM 树的过程。（DOM树全称 DOcument Object Model 即文档对象模型，它描述了标签之间的层次和结构， CSSOM 树，即 CSS 对象模型，主要描述样式集的层次和结构，CSS 解析器遍历其中每个规则，将 CSS 规则解析成浏览器可解析和处理的样式集合，最终结合浏览器里面的默认样式，汇合具有父子关系的 CSSOM 树）。

- 绘制：就是把各个节点绘制到屏幕上的过程，绘制结果以层的方式保存。当文档中各个部分以不同的层绘制时，相互重叠时，就必须进行合成。

- 解析 HTML
- 解析 CSS
- 解析 JS
- 生成 DOM 树
- 生成 CSSOM 树
- 生成渲染树
- 布局（Layout）
- 绘制（Paint）

- 构建 DOM 树的瓶颈点：
  - 当 HTML 标签不满足 Web 语义化时，浏览器就需要更多时间去解析 DOM 标签的含义。比如 br 标签少写了结束的符号，表格嵌套不标准，标签层次结构复杂等，这会导致浏览器会进行语法纠错，这就会导致页面总的解析和渲染阶段需要更长的事件，严重影响页面展示性能。
  - DOM 节点的数量越多，构建DOM树的时间就会变长，进而延迟解析时间，拖慢页面展示速度。
  - 文档中包含 `<script>` 标签时的情况，无论是 DOM 或者 CSSOM 都可以被 JavaScript 所访问并修改，所以一旦在页面解析时遇到 `<script>` 标签，浏览器会停止解析 DOM，DOM 的构造过程就会暂停，等待服务器请求脚本。外部 `<script>` 常被称为“解析”阶段的拦路虎，有时就因为解析过程多了一个 `<script>`，造成页面解析阶段从 200ms 变为 1s。所以外部脚本的加载时机一定要确定好，能够延迟加载选用延迟加载，通过使用 `defer` 和 `async`，告诉浏览器在等待脚本下载期间不阻止解析过程。

- 布局中的瓶颈点：
  - 浏览器会根据样式解析器给出的样式规则，来计算某个元素需要占据的空间大小和屏幕中的位置，借助计算结果，来进行布局。（主线程采用流模型的布局方式，就是从左到右，从上到下，遍历一遍所有的元素）。
  - 假设我们在页面渲染过程运行时修改了一个元素的属性，这时候布局阶段受到了影响，浏览器必须检查所有其他区域的元素，然后自动重排页面，相当于整个渲染流程重新来了一遍。
  - 因为浏览器每次布局计算都要作用于整个 DOM，如果元素量大，计算出所有元素的位置和尺寸会花很长的事件，所以布局阶段很容易成为性能瓶颈点。

比如没有确定列表页的图片初始大小，只给定了一个基础的占位尺寸，当图片加载完毕后，主线程才知道了图片的大小，不得不重新进行布局计算，然后再次进行页面渲染。


## 扩展点
- 偏硬件领域，像 GPU 绘图、操作系统 GUI 和 LCD 显示等瓶颈点；
- 网络层和服务层，如拥塞预防、负载均衡和慢启动；
- 页面解析和渲染的算法，如解析算法、标记化算法和树构建算法等。