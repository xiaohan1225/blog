## BT低代码平台

- 角色： 前端开发组长 
- 开始时间：2023-05

项目描述：面向企业内部运营人员的一个自研低代码平台，旨在快速搭建复杂的营销活动页和落地页，将开发效率提升 50% 以上。并支持响应式和跨平台。平台包含可视化拖拽设计器、业务事件编排、数据模型驱动引擎、应用发布与版本管理全流程。支撑了公司内部 300+ 营销活动专题页和落地页的搭建与运维。

<!-- 操作简单易用的同时，又能实现高度定制化的业务功能。内部支持最好用的编排引擎体系、丰富的数据源集成，以及可视化的变量系统 -->

技术栈：Vue3全家桶、pnpm、TypeScript、Vite、interactjs、CodeMirror 6等。

个人职责：
1、从0到1设计低代码平台架构，包括编排引擎、渲染引擎、变量系统、组件库、工程化和质量控制等全功能搭建，项目采用 Monorepo 微内核设计，并通过插件化的方式来扩展功能。
2、数据模型以及数据协议 Schema 设计、物料设计和物料管理平台搭建，以及动态 block 抽象设计。
2、编排引擎设计、优化编排引擎性能，物料拖拽与编排交互设计，基于 mouse 事件自研了拖拽放置引擎，实现了组件在画布内的自由拖拽、缩放、辅助线对齐与吸附功能。支持动态组件加载与实时布局调整，提升系统的响应速度和灵活性。
3、变量编辑器系统架构搭建。基于 CodeMirror 的代码编辑能力，支持用户定义和管理全局变量与逻辑配置，并支持通过黑名单对象 + Proxy 创建沙箱运行环境，保证变量编辑器的安全性。
4、渲染引擎 Renderer 的开发和优化,通过策略模式来进行数据转换加工。

项目难点：
1、复杂嵌套布局下的拖拽放置算法。当容器嵌套多层（如卡片内套表格，表格内套输入框）时，精准判断组件拖拽的目标容器和放置位置变得非常困难，经常出现错位或无法插入的问题。
  - 解决：采用 射线检测法 结合 最近父容器回溯算法。不再仅依赖鼠标坐标下的元素，而是通过计算组件树中每个容器的层级与区域，找到最合适的插入父节点，并将放置位置细分为“之前、之后、内部”三种状态，用蓝线高亮引导用户，放置准确率提升至 98% 以上。
2、性能瓶颈：拖拽卡顿问题，大量组件同时渲染，大数据 json 性能问题，在搭建复杂活动页面（100+ 组件）时，拖拽组件或修改配置会触发全量渲染，配置反馈延迟高达 2-3 秒。
  - 解决：采用分层优化策略，通过响应式优化、渲染优化、拖拽优化、json数据优化以及增量更新的方式，配置反馈延迟降至 200ms 以内，拖拽帧率稳定 60 FPS。
  - 增量更新，操作历史合并。
  - 采用分层优化策略
    - 响应式优化：用 shallowRef 管理组件树，避免深层响应式开销；用 markRaw 标记静态组件定义
    - 渲染优化：为每个组件实例绑定 v-memo，只有当组件 ID 和自身配置变化时才重新渲染
    - 拖拽优化：用mouse事件代替drag事件实现拖拽，鼠标按下的时候算出碰撞检测区域nodeArea，保存在内存中，mouseMove时，检测落在哪一个Area内，显示指示/编排线
    - json数据优化：fast-json-patch 实现增量更新，减少数据传输量，提升性能，注意增量更新时需要进行校验，如出现问题须降级至全量更新。
  - 可视区渲染（懒加载）
  - 优化后，配置反馈延迟降至 200ms 以内，拖拽帧率稳定 60 FPS
3、黑盒困境：低代码应用由配置生成，传统断点调试失效，难以定位和调试问题。
  - 解决：通过设计三层调试架构（业务层实时预览、实施层事件追踪、技术层性能火焰图，并通过权限系统进行控制），通过自定义调试面板，建立系统级/组件级别的追踪系统。监控事件流、性能、组件树、表达式执行、内存占用、用户操作、代码错误等场景，并通过表达式调试器，数据快照和数据对比等功能，帮助开发人员快速定位和解决问题。

项目成果
- 效率提升：平台上线 6 个月后，内部应用开发效率提升约 60%，原本需要 2 周开发周期的简单业务系统，现可在 2-3 天内完成搭建交付。
- 技术复用：封装 60 + 通用组件（容器、文本、图片、课程列表）与 30 + 业务组件（如优惠券、抽奖、倒计时等），覆盖投放引流、双十一、双十一、春节活动等营销投放场景，减少重复开发工作量。
- 性能优化：通过虚拟滚动、组件懒加载、缓存、防抖等方案，复杂页面（50 + 组件）拖拽响应时间从 300ms 降至 50ms 内，页面加载速度提升 40%。​
- 业务覆盖：累计生成 200 + 线上可用页面，服务 10+ 核心项目部门，并通过完善的日志、追踪和性能分析工具链，让问题定位时间缩短70%，线上 bug 率降低 60%。​
- 扩展能力：变量系统提供的「低代码片段」插槽机制，覆盖了 90% 以上的定制化需求，平台二次开发人力成本降低 70%。


<!-- - 业务覆盖：累计创建应用 35 个，服务 12 个核心业务部门，成为公司数字化转型的基础设施之一。 -->
<!-- - 技术复用：沉淀出内部组件库 40+ 个，包含 15 个业务通用组件（如业务树选器、部门选择器），并被其他 3 个前端项目复用。 -->
<!-- 支持 10 + 业务线落地：已为公司内部 10 余个业务线提供低代码开发支持，累计生成 200 + 线上可用页面，无重大线上故障。​ -->
<!-- 自定义组件接入效率提升 70%：设计标准化的组件接入规范与 SDK，第三方组件接入时间从 1 天缩短至 2 小时，支持 15 + 自定义组件稳定运行。 -->
 <!-- 性能优化成效显著 -->

以前开发一个活动专题页需要2-3天

- 提高效率：将重复性的基础增删改查代码交由平台自动生成，开发者只需要关注复杂的系统架构和核心业务逻辑。
- 降低沟通成本：业务人员可以通过可视化的原型，直观地看到最终系统的样子，减少了"你想要的和做出来的不一样"的风险。
- 赋能业务：让懂业务但不懂代码的同事，也能在 IT 部门的指导下构建或修改简单的应用，缓解 IT 资源紧张。


为什么要用 interactjs：
- 拖拽时滚动条不能滚动
- 可以支持容器resize

问题：
1. 鼠标按下拖拽和click事件没有区分，我们一般有两种策略，针对于mousedown事件的处理就是鼠标按下时长或者鼠标按下后移动距离来判断是点击还是拖拽
2. 碰撞检测细节优化

拖拽性能优化：
1. 虚拟区域优化
  - 使用 DocumentFragment 一次性插入多个节点，减少重绘（创建调试区域指示线的时候需要一次插入多个节点，然后appendChild(documentFragment)）
  - 提前缓存节点信息，避免重复查询DOM
  - 精确计算虚拟区域大小，减少内存占用
2. 滚动逻辑优化
  - 动态调整容器滚动逻辑，只在拖拽边界时触发滚动
  - 使用 requestAnimationFrame 优化滚动触发逻辑
3. 事件监听优化
  - 精确绑定事件目标，避免不必要的全局监听
  - 使用防抖技术优化高频事件，例如拖拽的 mousemove
  - 避免不必要的重绘操作，例如动态调整指示器


难点：可视化配置与代码灵活性的平衡（低代码片段）

问题：业务方反馈纯拖拽无法满足定制化需求，如表格列根据状态显示不同颜色，直接写代码又违背低代码初衷。

解决：设计安全沙箱的表达式绑定机制。

基于 new Function() 配合 with 语句 + Proxy 拦截实现安全执行沙箱，注入 record、$utils 等上下文

在表格组件中集成表达式解析，支持 `{{ record.status === 'success' ? '#52c41a' : '#f5222d' }}` 语法

基于 Monaco Editor 提供智能提示和实时预览，降低业务人员使用门槛

该机制支撑了 80% 的定制化需求，大幅减少二次开发投入

## 调试问题

前端性能监控sdk结合低代码：
- 建立组件级别的追踪系统，上报组件信息，统计渲染速度（慢渲染警告，组件updated超过 16ms (60fps)），错误捕获onErrorCaptured（组件id，上下文信息，报错信息），追踪渲染、用户操作、错误、表达式执行
- 表达式调试器
  - 拦截表达式执行，检测有断点进行调试模式
  - 在安全沙箱中执行，记录执行结果
  - 实现表达式单步调试：拆解表达式为 AST，逐节点执行
- 实现自定义调试面板（总览：事件流、表达式、页面性能、当前选择组件及渲染次数、错误个数、平均响应时间、内存占用等，支持数据快照和数据对比）
  - 事件流标签页：用户操作action、慢渲染警告 warn、表达式执行失败ERROR、重新渲染RENDER，包含时间轴
  - 性能标签页：页面初始化时间、数据加载时间（API请求、数据处理）、首次渲染时间（组件渲染时间、表达式计算时间、数据处理时间）、布局计算时间，给出慢组件建议（API接口慢、初渲染慢、更新慢）
  - 组件树标签页：组件数据、组件渲染次数、组件更新时间等
  - 表达式调试标签页：执行、断点、单步、重置
  - 数据快照

[性能报告] 页面加载耗时分析
├─ 初始化 (120ms)
│  ├─ 组件树构建 (45ms)
│  └─ 数据加载 (75ms)
├─ 首次渲染 (230ms)
│  ├─ Table 组件 (120ms) ⚠️ 慢
│  │  ├─ 列渲染 (80ms)
│  │  └─ 表达式计算 (40ms)
│  ├─ Form 组件 (60ms)
│  └─ 其他组件 (50ms)
└─ 交互响应 (平均 45ms)
   ├─ 点击响应 (12ms)
   └─ 表达式计算 (33ms)

调试工具链的核心价值：
- 非侵入式：调试代码不应影响业务逻辑
- 可复现：能重现用户遇到的问题
- 可视化：把复杂问题用直观的方式呈现
- 分层设计：不同用户看到不同维度的信息


用户角色	技术背景	关心的问题	调试需求
业务人员	无代码经验	我的配置为什么没生效？表格颜色不对	简单的配置检查、表达式预览
实施顾问	懂业务逻辑，会写简单表达式	流程为什么走不通？数据哪里错了	数据流追踪、表达式调试
前端开发者	专业编程	性能为什么慢？组件为什么崩溃？	性能分析、错误堆栈、组件树
平台开发者	低代码平台自身开发	平台的 bug 在哪里？	完整的技术细节、源码级调试

如果给所有用户展示同样的调试信息：
- 业务人员会被海量技术信息淹没
- 开发者又觉得信息不够深入
- 分层设计的核心：根据用户角色，提供刚好够用、恰好合适的调试信息。

┌─────────────────────────────────────────────────────────────┐
│                       L1: 业务层                             │
│  (业务人员、运营人员)                                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 配置检查器                                          │   │
│  │ • 表达式预览                                          │   │
│  │ • 数据快照                                            │   │
│  │ • 简单的错误提示                                       │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       L2: 实施层                             │
│  (实施顾问、技术支持)                                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 事件流追踪                                          │   │
│  │ • 表达式调试器                                        │   │
│  │ • 数据流分析                                          │   │
│  │ • API 请求日志                                        │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       L3: 技术层                             │
│  (前端开发者、平台开发者)                                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │ • 性能火焰图                                          │   │
│  │ • 组件树深度分析                                      │   │
│  │ • 渲染追踪                                            │   │
│  │ • 源码映射                                            │   │
│  │ • 内存分析                                            │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘



- 针对大画布场景，采用 shallowRef + markRaw 减少响应式代理开销，结合 v-memo 指令避免无效渲染，确保 100+ 组件时拖拽操作保持 60 FPS 流畅度
- 设计并落地协议版本管理机制，支持搭建页面的平滑升级与历史版本回滚
- 基于 IndexedDB 实现自动保存功能，避免浏览器崩溃导致内容丢失


目前还需要优化的部分：
1. 项目升级成本高
2. 协同编辑，如何处理冲突，离线操作
3. 交互动画与过渡效果

为什么要有变量系统：
- 画图工具 -> 开发平台
- 简单的"拖拽式"建模难以清晰表达复杂的条件分支和状态转换

变量编辑器的系统架构：
- CodeMirror 6 编辑器核心实现（使用Lezer/ternjs做语法解析）
- 变量编辑器的核心架构
  - 模块化架构：通过分离核心逻辑与功能扩展，降低耦合，提升可维护性
  - 灵活配置：通过动态扩展实现灵活功能，如单行模式、自定义高亮
  - 样式定制：主题文件提供全方位的样式控制，满足不同场景需求
- 变量执行器的架构与实现
  - 变量执行器是变量编辑器中实现动态变量解析和代码片段执行的核心模块。它通过一个沙箱环境安全地执行用户脚本，同时注入上下文数据（dataTree），以保证代码运行不会对主环境产生影响。
  - 沙箱环境
    - 核心作用是隔离运行环境，在执行不可信代码时保护宿主环境的安全。
    - 沙箱的主要优势
      - 隔离作用域
        - 防止用户代码访问变量或篡改宿主环境的全局对象（如window、document）
        - 限制用户代码对黑名单对象（如DOM操作、网络请求）的访问
      - 保护宿主环境
        - 避免用户代码对全局变量或原型链的意外修改
        - 防止恶意代码直接调用主环境的敏感API
 - 系统与用户变量提供器架构实现
  - 系统与用户变量提供器时动态变量管理与使用的核心模块，通过统一的变量系统提供开发环境中变量的动态注入、解析和管理功能。架构实现结合状态管理（zustand）和自定义 Hook，提供了一种高效的变量管理与接入机制。
  - 系统变量与用户变量的定义
    - 系统变量
      - 预定义的全局变量，如 currentUserInfo 和 currentAppInfo
      - 通常与系统级环境相关，开发时提供上下文信息
    - 用户变量
      - 用户自定义的动态变量，通过 Block（如按钮组件）等注入到变量系统中
      - 反映用户的应用结构和配置。



插件化设计：
- 顶部条：前进、后退
- 物料区也可以有插件：主要表现就是用脚手架来扩展物料
- 画布区也可以有插件：比如选中组件的时候可以扩展复制、删除、辅助线、上移下移等功能
- 设置区也可以有插件：比如颜色选择器，可以追加自定义表单项

操作历史有两种实现方案：
1. 每次操作保存一份新的json，性能差
2. 每一次操作是一个action，比如我添加了一个元素，对应 add(comp) 方法，那我回退的时候就是执行它的反向操作 remove(comp) 来修改，麻烦的地方就在于每个操作都需要写一个对应的反向操作的方法


mouse事件相比于drag事件
- 性能更高，mouse 事件可以实时获取鼠标坐标进行碰撞检测、辅助线对齐等复杂计算，计算过程与渲染同步。HTML5 Drag 在这些场景下往往需要额外的 hack 才能实现。mouse 事件可以精细控制何时触发视图更新，而 HTML5 Drag 的默认行为可能会频繁触发浏览器的重绘和重排。

基础block抽象
```ts
interface BaseBlockProtocol {
  id: string;
  title: string;
  type: string;
  props: {
    size: SizeProtocol;
    style: StyleProtocol;
  }
}
```

- 数组结构：承载框架结构数据，block区块化
- map结构：整个页面中block的具体内容
- 细粒度的状态订阅，减少renderer的范围
- 数据分层 -> 设计状态 -> 细颗粒度订阅

对齐方式
- 左对齐，居中对齐、右对齐、分布对齐、等距对齐

鼠标事件：横向纵向增量delta很容易计算
- 鼠标按下，算出碰撞检测区域nodeArea，保存在内存中
- mouseMove时，检测落在哪一个Area内，显示指示/编排线


为什么选择CodeMirror而不选择Monaco Editor？
- 轻量，支持按需加载（300k gzip），Monaco Editor约（1.2MB gzip）
- 极致模块化，可定制
- 很方便集成，vue-codemirror

## 微前端沙箱的实现
1. 动态代理沙箱：使用 Proxy 动态代理全局对象，对每个字应用提供隔离的全局变量视图。
2. 快照沙箱
  - 在子应用运行前保存全局变量的快照。
  - 在子应用卸载时恢复全局变量状态。
3. CSS 隔离
  - 为子应用注入独立的 CSS 前缀，避免样式冲突

微前端与变量编辑器的沙箱对比：
| 功能 | 微前端沙箱 | 变量编辑器沙箱 |
|---------|---------|---------|
| 作用域隔离   | 不同子应用之间的隔离   | 用户代码与宿主环境隔离   |
| 数据注入   | 子应用独立的上下文数据   | 动态注入dataTree数据   |
| 安全保护   | 防止子应用污染全局变量或原型链   | 限制用户代码对全局对象的访问   |


## 低代码的难点
首先设计一个能够面向不同业务场景的低代码项目，是个不小的挑战。
比如一个公司级别的低代码项目，目标是赋能各条业务线。这个就会有一个问题：每个业务对低代码平台的能力要求是不同的，除了大量可复用的功能，肯定也会有不少的定制化需求。甚至各条业务线的产品形态很不一致，有面向C端的，有面向B端的。
如果是中心化的思想，一套低代码平台，满足各业务线的需求，首先人力成本很难均摊下去，其次平台随着接入业务线增多，不可避免的会变得臃肿不堪，难以维护。如果每个业务线都独立做一套符合自身业务特性的低代码，这样难度会降低不少，但也意味着公司级别的低代码物料复用变得困难。
讲下业界目前比较流行的解决方案：
- 在公司级甚至业界推动低代码协议统一。这样就让跨业务甚至业界的物料复用变得可能，阿里前端委员会为此付出了不少努力，大家有空可以了解下。
- 将低代码架构分层。先有一个低代码基础架构，再用它去“生成”一个个面向具体业务场景的低代码平台。那么如何设计好这个“生成低代码平台的低代码平台”就成为了重中之中。这有点类似于低代码“中台”与“前台”的关系。
