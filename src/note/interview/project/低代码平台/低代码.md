## 操作历史


## 扁平式数据结构
- 优化操作历史的实现方式
  - 全量 -> 增量（JSON数据可能会达到2-3M，全量保存消化内存夸张）
  - 操作历史合并（同一个节点 + 同一个属性）
- 实时编辑属性、实时更新
- 协同编辑（参考在线文档），如何处理冲突，离线操作

## 组件清单
- 基础组件
  - 单行文本
  - 图片
  - 按钮
  - 滚动文字
  - 多行文本
  - 视频
  - 锚点
  - 模版
  - 图标
- 容器组件
  - 多行容器
  - 多列容器
  - 轮播容器
  - 弹框容器
  - 固定容器
  - 方形容器
  - 粘性容器
  - 宫格容器
  - 标签容器
## 操作历史
## 组件层级


## 样式操作
- 显示设置
  - 元素类型（块级、行级）
  - 背景设置
  - 透明度
  - 溢出
- 对齐设置
  - 主轴方向
  - 弹性换行
  - 主轴对齐方式
  - 交叉轴对齐方式
  - 弹性设置
  - 弹性尺寸
  - 弹性放大
  - 弹性缩小
  - 自身元素度对齐
  - 主轴空间大对齐
  - 浮动设置
  - 首选纵横比
- 文字设置
  - 文字颜色
  - 文字大小
  - 文字对齐
  - 最后对齐
  - 文字行高
  - 文字间距
  - 换行设置
  - 断行设置
- 尺寸设置
  - 宽度
  - 最小宽度
  - 最大宽度
  - 高度
  - 最小高度
  - 最大高度
- 外边距设置
  - 外边距
- 内边距设置
  - 内边距
- 边框设置
  - 边框类型
  - 边框颜色
  - 边框大小
  - 圆角设置
- 定位设置
  - 定位类型
  - 层级优先级
  - 元素定位
  - 鼠标事件
- 变换设置
  - 变换设置（比如skew(45%)）
  - 变换原点
  - 位置平移
  - 大小缩放
  - 旋转变换
- 滤镜
  - 滤镜（比如brightness(0.5)）

## 变量引擎
- 变量的作用域
- 变量对的初始化类型
- 变量的数据类型
- 变量的泛型
- 模板变量
- 批量渲染

绑定变量：
- 自有变量
  - 新建变量
    - 自定义类型
    - 接口查询
      - 变量名称
      - 变量标识
      - 依赖变量
      - 是否禁用阻塞渲染
      - 接口模版
      - 接口返回类型
      - 当前实体数据类型
      - 接口地址
      - 请求方法
      - 地址参数
      - 请求参数
      - 请求头
      - 是否禁用分页参数
      - 查询所有数据
      - 页大小
      - 起始页码
      - 分页类型（比如拼接数据）
    - 规则变量（相当于一个函数，返回值一个计算后的值）
    - 绑定变量
      - 变量名称
      - 变量标识
      - 依赖变量
      - 是否禁用阻塞渲染
      - 绑定值（可以绑定某个变量实现变量别名的效果）
    - 模版变量（相当于渲染函数，输出值为渲染的内容，有一个模板组件，专门渲染模板变量）
      - 变量名称
      - 变量标识
      - 依赖变量
      - 是否禁用阻塞渲染
      - 模版类型
        - 自定义（可支持图片）
        - 绑定
        - 引用
  - 变量列表
- 继承变量

## 规则引擎
- 规则引擎的作用
- 为什么使用规则引擎而不是流程引擎
  - 流程节点改业务需求不好改
  - 很乱，不清晰
- 给定一个国庆期间下单活动，订单金额达到固定金额就赠送余额/积分

需求变更：
- 国庆期间下单限制取消
- 目前是赠送余额之后不再赠送积分，改成既赠送余额也赠送积分
- 更改逻辑，只有国庆最后两天才会赠送积分

节点类型：
- 并且执行-and
- 或者执行-any
- 并且并发-all
- 或者并发-race
- 数组循环-while
- 数组过滤-filter
- 变量赋值-set
- 接口调用-query
- 空值判断-hasValue
- 日期范围判断-dateRange
- 日期时间范围盘判断-datetimeRange
- 数字范围判断-numberRange
- 字符串相当判断-stringEqual
- 布尔值判断-boolean
- 数字运算-numberCrunching
- 调用规则（拷贝）-copyRules
- 调用规则（引用）-referRules



## 黑名单设置
- 通过 `blackListSet` 列出不可访问的全局对象（如 document、fetch）
- 在沙箱中访问这些对象时返回一个黑洞代理，避免报错

```js
const blackListSet = new Set([
  'top',
  'self',
  'parent',
  'global',
  'globalThis'
  'document',
  'fetch',
  'window',
  'frames',
  'XMLHttpRequest',
  'MutationObserver',
]);
```

## 黑洞代理
- 任何对黑名单对象的访问，都会返回一个虚拟的“黑洞对象”
- 黑洞对象会吞掉任何访问或调用，而不会抛出异常

```ts
function createBlackHole() {
  return new Proxy(
    function () {
      return createBlackHole();
    },
    {
      get(_, p) {
        if (p === 'toString' || p === Symbol.toPrimitive) {
          return createBlackHole();
        }
      },
    }
  )
}
```

## 沙箱代理
- 使用 `Proxy` 创建沙箱对象，拦截用户代码对全局对象的访问。
- 对于黑名单对象，返回黑洞代理；对于正常对象，返回真实值或绑定后的函数。

```ts
function createMockWindow(base?: object) {
  const win: any = new Proxy(Object.assign({}, base), {
    get(target, p) {
      if (globalVarNames.has(p)) return win;
      if (blackListSet.has(p as string)) return createBlackHole();
      return Reflect.get(window, p);
    }
  })
  return win;
}
```

## 沙箱运行代码
- 使用 `with` 语句注入沙箱对象，将用户代码与沙箱隔离。
- 通过严格模式（'use strict'）防止意外的全局变量泄漏。

```ts
function runUsersCode(code: string) {
  const finalCode = `with(this) {

    return (function() {
      'use strict';
      return (${code});
      }).call(this);
  }`
  return new Function(finalCode);
}
```