## 项目描述

主导去调研了 Sentry 平台，Sentry 是业界非常主流和强大的产品，它里面提供了 xx 特性，我整体架构设计了监控平台 sdk、监控平台服务端、监控平台的数据清洗、数据处理、再到监控平台可视化引擎、可视化链路整个全链路的设计。

## 指标体系设计

- 性能
  - CLS：累积布局偏移，衡量页面布局稳定性
  - LCP：最大内容绘制时间，衡量页面主要内容的加载速度
  - TTFP：首字节时间，衡量服务器的响应速度
  - INP：交互到下一次绘制的时间，衡量页面响应交互的速度
  - FP：首次向屏幕绘制内容的时间
  - FCP：浏览器首次绘制出内容元素的时间
  - FMP：首次绘制用户关注内容的时间（这个不是一个标准指标）
- 异常
  - js 代码异常
  - 异步处理异常
  - 资源加载异常
- 用户行为
  - 也称为用户行为（事件 click mousedown）埋点，SDK（手工埋点、无痕埋点、可视化埋点）
- 数据请求与资源
  - fetch、xhr 原型重写

## 性能采集

使用 web-vitals，这是标准化库。

```ts
import { getCLS, getFID, getLCP, getTTFB } from 'web-vitals';

getCLS(onCLS);
getFID(onFID);
getLCP(onLCP);
getTTFB(onTTFB);
```

## 异常采集

```ts
window.addEventListener('error', (event) => {
  const { message, filename, lineno, colno, error } = event;
  // 发送错误信息
});

window.addEventListener('unhandledrejection', (event) => {
  const { reason } = event;
  // 发送错误信息
});
```

但这里需要考虑跨平台，不能把 window 写死。

GLOBAL_OBJ
- 浏览器端 window
- node 端 globalThis
- 小程序端

```ts
const getCurrentScope = () => window;
```

## Node 性能采集


在 Node.js 中，我们可以使用 node:perf_hooks 模块来实现与 W3C Web Performance API 相关的功能。这些功能通常用于监控代码性能。帮助开发者理解代码执行的效率。Node.js支持以下几个Web性能API:
1. High Resolution Time: 提供高精度的时间测量，可以精确到微秒级别。
2. Performance Timeline: 允许记录和观察代码运行的性能事件。
3. User Timing: 允许开发者为特定的代码片段标记时间，以便计算执行时长。
4. Resource Timing:用于收集和记录应用程序中加载资源的性能数据。

## 事件采集
事件采集是用户操作行为监控的核心，包括对 DOM事件、XHR请求、Fetch请求等的采集。Sentry通过对原生方法的代理，捕获用户操作并记录在系统中。

事件类型：
- DOM事件：例如点击、键盘输入等用户操作。
- XHR和Fetch请求：通过代理原生的XMLHttpRequest和fetch,捕获每个网络请求的详情，包括URL、响应时间、状态码等。
- History和Navigation API事件：捕获页面导航行为，如前进、后退操作等。

实现原理：
- 我们可以通过重写addEventListener方法，来捕获用户在页面上进行的点击、键盘输入等操作。同时，通过代理XMLHttpRequest和fetch来拦截网络请求，并记录相关信息。
- xhr：通过重写XMLHttpRequest.prototype.send方法，在发送请求前记录相关信息。
- fetch：通过重写fetch方法，`window.fetch = xxx` 在发送请求前和请求完成后记录相关信息。


## 架构包
- packages/browser: 针对原生浏览器封装埋点上传sdk
- packages/browser-utils: 浏览器端功能函数
- packages/core: 整个监控 sdk 的核心层
- packages/vue:  整个监控 sdk 在 vue 层的适配
- packages/react:  整个监控 sdk 在 react 层的适配
- packages/types:  整个监控 sdk 的类型定义
- packages/utils:  整个监控 sdk 的处理函数

## 总结
- 工程化设计
- SDK 封装
  - 指标采集（空闲时发送，发送队列）
  - 指标上报
- SDK dsn server
  - Kafka 来做消息队列
    - topics
    - partition
  - clickhouse
    - 列式存储
  - 数据处理聚合统计
- 监控 Sass 平台
  - 创建应用
  - 监控应用的指标
- CI/CD
  - Docker

整体过程
- 前端项目插入sdk，通过行为触发埋点
- 监控平台sdk上报服务端
- 服务端削峰限流（Kafka做中间层消息队列，消息队列去分发、削峰，保证服务稳定），数据清洗整合，落库 clickhouse
- 数据从 SDK 采集到 dsn 服务、入库 clickhouse、数据统计、监控平台服务数据消费全流程设计。

## SDK数据采集与上报核心实现思路
> 我们主要讲解核心指标采集与监控数据整体流程，后续如果有需要自定义事件和数据采集的，可以借助MutationObserver或Performance API 进行处理

### 设计概要
#### 核心模块设计
要实现一个前端性能监控和异常埋点，我们需要以下几个核心模块：
1. 网页性能指标采集(FP、FCP、CLS等)：通过web-vitals采集这些性能指标。
2. 异常采集：监控JS错误、资源加载错误和未捕获的Promise错误。
3. 点击事件采集：捕获用户点击行为，记录交互路径。
4. 基础信息采集：采集 IP、机型、系统、浏览器等设备及环境信息。
5. 数据传输协议：统一封装不同类别的数据，发送给后端。
#### 核心目标
1 .插件化设计：支持性能、异常、点击事件等不同采集插件。
2. 跨环境兼容：支持浏览器和Node服务端的数据上报。
3. 代码解耦：数据传输逻辑与采集逻辑分离，方便维护与扩展。
4. Monorepo:多包管理模式，提升代码复用和管理效率。

### SDK核心架构设计
- @miaoma/monitor-sdk-core
  - 定义核心逻辑和Transport接口。数据处理、约束、协议定义、上层设计。
  - 负责插件初始化与注册。
- @miaoma/monitor-sdk-browser
  - 浏览器相关插件：性能、异常、点击事件采集。
  - 自定义浏览器 Transport 上报实现。
- @miaoma/monitor-sdk-browser-utils（为什么要单独抽离出一个包，比如vue、react等扩展包也属于浏览器端，里面的工具方法都可以抽象到这里）
  - 提供浏览器环境下的工具方法。
- @miaoma/monitor-sdk-node
  - 适配 Node 环境的 Transport 上报实现。